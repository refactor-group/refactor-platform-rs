//! Types for AI-powered transcript analysis and resource extraction.

use crate::Error;
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt::Debug;

/// Trait that all extractable resources must implement.
///
/// Provides common metadata interface while allowing completely custom fields and behavior.
/// Applications define domain-specific types (e.g., SeaORM models, DTOs, plain structs).
/// Examples: coaching actions, sales leads, medical diagnoses, project tasks, etc.
/// Type must be Clone, Send, Sync for async processing and Serialize/Deserialize for API responses.
pub trait ExtractedResource: Debug + Clone + Send + Sync + Serialize + DeserializeOwned {
    /// Unique identifier for the resource type defined by the application.
    ///
    /// Examples: "coaching_action", "sales_lead", "diagnosis", "task", "risk", "decision"
    /// Used for routing, storage, API responses, and distinguishing resource types.
    /// Must be consistent across all instances of this type.
    fn resource_type(&self) -> &'static str;

    /// Primary text content extracted from the transcript.
    ///
    /// Required for all resources; the core information being captured.
    /// This is the main human-readable description of what was extracted.
    fn content(&self) -> &str;

    /// AI confidence score (0.0-1.0) indicating extraction quality.
    ///
    /// Use to filter low-confidence extractions or flag items for human review.
    /// Scores below 0.7 typically indicate ambiguous phrasing requiring validation.
    fn confidence(&self) -> f64;

    /// Timestamp in milliseconds from meeting start where this was mentioned.
    ///
    /// None if resource spans multiple time ranges or timestamp unavailable.
    /// Enables linking resources back to specific moments in recording/transcript.
    fn timestamp_ms(&self) -> Option<i64>;
}

/// Single mention of a topic with context and timestamp.
///
/// Enables users to navigate to specific parts of the conversation.
/// Text provides snippet of surrounding discussion for context.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopicMention {
    pub text: String,
    pub timestamp_ms: i64,
}

/// Key topic identified across the conversation with all mentions.
///
/// Relevance_score ranks topics by prominence; use for navigation and insights.
/// Mentions provide timestamps for jumping to topic discussions in recording.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Topic {
    pub name: String,
    pub relevance_score: f64,
    pub mentions: Vec<TopicMention>,
}

/// Structured summary of meeting content generated by LLM.
///
/// Organizes conversation into logical categories for quick review and sharing.
/// Quality depends on transcript accuracy and prompt engineering.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Summary {
    pub overview: String,
    pub key_points: Vec<String>,
    pub goals: Vec<String>,
    pub challenges: Vec<String>,
    pub insights: Vec<String>,
    pub next_steps: Vec<String>,
    pub topics: Vec<Topic>,
}

/// LLM token consumption metrics for cost tracking and optimization.
///
/// Input_tokens = transcript + prompt; output_tokens = generated analysis.
/// Monitor these to optimize prompt length and detect cost anomalies.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenUsage {
    pub input_tokens: u32,
    pub output_tokens: u32,
}

/// Complete result from AI analysis with flexible resource types.
///
/// Stores extracted resources grouped by type in a type-erased format for maximum flexibility.
/// Applications can extract any number and types of resources based on domain needs.
/// Use get_resources() for type-safe deserialization of specific resource types.
/// Token_usage helps track LLM costs and optimize prompts for efficiency.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Result {
    pub request_id: String,
    /// Extracted resources grouped by resource_type (e.g., "coaching_action", "sales_lead").
    /// Stored as JSON values to support any application-defined resource types.
    /// Use get_resources::<T>() to deserialize resources of a specific type.
    pub resources: HashMap<String, Vec<serde_json::Value>>,
    pub summary: Option<Summary>,
    pub token_usage: Option<TokenUsage>,
}

impl Result {
    /// Type-safe extraction of resources by type.
    ///
    /// Deserializes all resources matching the specified type T.
    /// Returns empty Vec if no resources of that type exist.
    /// Returns error if deserialization fails (indicates type mismatch).
    ///
    /// # Example
    /// ```ignore
    /// let actions: Vec<CoachingAction> = result.get_resources()?;
    /// let leads: Vec<SalesLead> = result.get_resources()?;
    /// ```
    pub fn get_resources<T: ExtractedResource>(&self) -> std::result::Result<Vec<T>, Error> {
        let type_key = std::any::type_name::<T>().split("::").last().unwrap_or("");

        self.resources
            .get(type_key)
            .map(|values| {
                values
                    .iter()
                    .map(|v| {
                        serde_json::from_value(v.clone())
                            .map_err(|e| Error::Deserialization(e.to_string()))
                    })
                    .collect()
            })
            .unwrap_or_else(|| Ok(vec![]))
    }

    /// Add resources of a specific type to the result.
    ///
    /// Used by provider implementations to populate the result with extracted resources.
    pub fn add_resources<T: ExtractedResource>(
        &mut self,
        resources: Vec<T>,
    ) -> std::result::Result<(), Error> {
        if resources.is_empty() {
            return Ok(());
        }

        let type_key = resources[0].resource_type().to_string();
        let values: std::result::Result<Vec<serde_json::Value>, _> = resources
            .iter()
            .map(|r| serde_json::to_value(r).map_err(|e| Error::Serialization(e.to_string())))
            .collect();

        self.resources.insert(type_key, values?);
        Ok(())
    }
}

/// Meeting participant with role and speaker label mapping.
///
/// Speaker_label links to transcription output (e.g., "Speaker A") for name resolution.
/// Role provides context to LLM for better resource attribution and entity resolution.
/// Examples: "coach"/"coachee", "doctor"/"patient", "sales_rep"/"prospect", "manager"/"employee"
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Participant {
    pub name: String,
    pub role: Option<String>,
    pub speaker_label: Option<String>,
}

/// Configuration for LLM-powered transcript analysis.
///
/// Completely domain-agnostic - applications define extraction requirements via prompts.
/// Provide participant context to improve speaker attribution and name resolution.
/// Resource_types specifies what to extract (e.g., ["coaching_action", "sales_lead"]).
/// Custom_prompt provides detailed extraction instructions for the LLM.
#[derive(Debug, Clone)]
pub struct Config {
    pub transcript_id: String,
    pub participants: Vec<Participant>,
    /// Types of resources to extract (e.g., "coaching_action", "sales_lead", "diagnosis").
    /// Provider uses these to structure extraction prompts and organize results.
    pub resource_types: Vec<String>,
    pub generate_summary: bool,
    /// Custom prompt with domain-specific extraction instructions.
    /// Should describe what each resource type means and what fields to extract.
    /// Example: "Extract coaching_action items with assignee, due_date, and priority fields."
    pub extraction_prompt: String,
    pub model: Option<String>,
    pub provider_options: HashMap<String, String>,
}

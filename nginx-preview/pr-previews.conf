# PR Preview Environments - Dynamic Path-Based Routing
# This config handles ALL PR previews with regex-based routing
# No per-PR config generation needed!
#
# URL Pattern: http://neo.rove-barbel.ts.net/pr-<NUM>/
# Example: http://neo.rove-barbel.ts.net/pr-201/
#
# Routing:
#   /pr-123/        → pr-123-frontend-1:3000 (Next.js frontend)
#   /pr-123/api/    → pr-123-backend-1:4000  (Rust backend)
#   /pr-123/health  → Health check endpoint
#
# Deployed via: docker-compose.nginx-preview.yaml
# Source: nginx/conf.d/pr-previews.conf (canonical version)

# Docker DNS resolver for dynamic container name resolution
# This allows NGINX to resolve pr-<NUM>-frontend-1 and pr-<NUM>-backend-1 dynamically
# Works because this nginx runs inside a Docker container on the preview-ingress network
resolver 127.0.0.11 valid=10s ipv6=off;

# Main server block — accepts both short MagicDNS name and FQDN
server {
    listen 80;
    server_name neo neo.rove-barbel.ts.net;

    # Request ID for tracing
    set $request_id_value $http_x_request_id;
    if ($request_id_value = "") {
        set $request_id_value $request_id;
    }

    # Global health check (reports NGINX status)
    location = /health {
        access_log off;
        return 200 "Neo NGINX healthy\n";
        add_header Content-Type text/plain;
    }

    # PR Preview Health Check: /pr-<NUM>/health
    # Returns 200 OK if the PR number is valid
    location ~ ^/pr-(\d+)/health$ {
        set $pr_number $1;
        access_log off;

        # Return simple health response
        # Note: This doesn't check if containers exist, just confirms NGINX routing
        return 200 "PR #$pr_number routing active\n";
        add_header Content-Type text/plain;
        add_header X-PR-Number $pr_number;
    }

    # PR Preview Backend API root: /pr-<NUM>/api (no trailing slash or sub-path)
    # The backend has no root handler, so return a helpful JSON response
    location ~ ^/pr-(\d+)/api$ {
        set $pr_number $1;
        default_type application/json;
        return 200 '{"status": "ok", "pr": $pr_number, "endpoints": ["/health", "/login", "/organizations", "/coaching_sessions"]}';
    }

    # PR Preview Backend API: /pr-<NUM>/api/*
    # Routes to pr-<NUM>-backend-1:4000
    # Strips /pr-<NUM>/api prefix, proxies remaining path
    location ~ ^/pr-(\d+)/api(/.+)$ {
        set $pr_number $1;
        set $api_path $2;

        # Dynamic upstream resolution
        # Docker DNS will resolve pr-<NUM>-backend-1 if container exists
        set $backend_upstream pr-${pr_number}-backend-1:4000;

        # Proxy to backend container
        # $api_path always starts with / (guaranteed by regex /.+)
        proxy_pass http://$backend_upstream$api_path$is_args$args;

        # Standard proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Request-ID $request_id_value;
        proxy_set_header X-PR-Number $pr_number;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # CORS headers (match PR-specific origin)
        add_header 'Access-Control-Allow-Origin' '$scheme://$host' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, PATCH, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;

        # Handle CORS preflight
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' '$scheme://$host' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, PATCH, DELETE, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;
            add_header 'Access-Control-Max-Age' 1728000;
            add_header 'Content-Type' 'text/plain; charset=utf-8';
            add_header 'Content-Length' 0;
            return 204;
        }

        # Error handling
        proxy_intercept_errors on;
        error_page 502 503 504 = @backend_error;
    }

    # PR Preview Frontend: /pr-<NUM>/
    # Routes to pr-<NUM>-frontend-1:3000
    # With basePath configured, Next.js expects the full /pr-<NUM>/... path
    location ~ ^/pr-(\d+)(/.*)?$ {
        set $pr_number $1;

        # Dynamic upstream resolution
        set $frontend_upstream pr-${pr_number}-frontend-1:3000;

        # Proxy to frontend container
        # Pass full original URI — Next.js basePath handles the /pr-<NUM>/ prefix
        proxy_pass http://$frontend_upstream$request_uri;

        # Standard proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Request-ID $request_id_value;
        proxy_set_header X-PR-Number $pr_number;

        # WebSocket support (for Next.js HMR)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Buffering
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;

        # Error handling
        proxy_intercept_errors on;
        error_page 502 503 504 = @frontend_error;
    }

    # Error page for backend unavailable
    location @backend_error {
        default_type application/json;
        return 502 '{"error": "Backend service unavailable", "message": "The PR preview backend is not running or cannot be reached"}';
    }

    # Error page for frontend unavailable
    location @frontend_error {
        default_type text/html;
        return 502 '<html><body><h1>PR Preview Unavailable</h1><p>The preview environment is not running.</p><p>This usually means the Docker container has not been deployed yet or has been cleaned up.</p><a href="javascript:location.reload()">Retry</a></body></html>';
    }

    # Security: Block access to hidden files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }

    # Default fallback for root path
    location = / {
        default_type text/html;
        return 200 '<!DOCTYPE html>
<html>
<head>
    <title>Neo PR Previews</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }
        h1 { color: #333; }
        code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
        .pr-link { margin: 10px 0; padding: 10px; background: #f9f9f9; border-left: 3px solid #0066cc; }
    </style>
</head>
<body>
    <h1>Neo PR Preview Environment</h1>
    <p>Access PR previews using the pattern:</p>
    <div class="pr-link">
        <code>http://neo.rove-barbel.ts.net/pr-&lt;NUMBER&gt;/</code>
    </div>
    <h3>Examples:</h3>
    <ul>
        <li>PR #201 Frontend: <a href="/pr-201/">http://neo.rove-barbel.ts.net/pr-201/</a></li>
        <li>PR #201 Backend API: <a href="/pr-201/api/">http://neo.rove-barbel.ts.net/pr-201/api/</a></li>
        <li>PR #201 Health: <a href="/pr-201/health">http://neo.rove-barbel.ts.net/pr-201/health</a></li>
    </ul>
    <p><small>NGINX running on Neo (Raspberry Pi 5) — containerized via docker-compose.nginx-preview.yaml</small></p>
</body>
</html>';
    }
}

# WebSocket connection upgrade mapping
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

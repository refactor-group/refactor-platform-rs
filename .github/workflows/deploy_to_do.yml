name: Deploy to DigitalOcean via Tailscale # Workflow name displayed in GitHub UI
# Deploys the latest stable tagged container images to production servers.

# Manual trigger with debug ssh option
on:
  workflow_dispatch: # Manual trigger via GitHub UI
    inputs:
      enable_ssh_debugging: # Optional debugging parameter useful to debug the ssh connection to the server
        description: "Enable verbose SSH debugging" # Help text shown in UI
        required: false # Not required to run the workflow
        default: false # Disabled by default
        type: boolean # Simple checkbox in the UI

permissions:
  contents: read # Minimal permissions required for this workflow

jobs:
  deploy:
    name: Manual Deploy Over Tailscale # Display name for this job
    runs-on: ubuntu-24.04
    environment: production # Use the production environment settings

    steps:
      # Step 1: Setup Tailscale on the GitHub Actions runner
      - name: Set up Tailscale # Connect to the Tailscale network
        uses: tailscale/github-action@v3 # Official Tailscale GitHub Action
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }} # OAuth client ID for Tailscale
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }} # OAuth client secret for Tailscale
          tags: tag:github-actions # Tag to identify this connection in Tailscale
          version: latest # Use the latest version of Tailscale
          use-cache: "true" # Cache Tailscale binary for faster startup

      # Step 2: (Debug only) Verifies SSH ED25519 SSH key
      - name: Debug ED25519 Key # SSH key debugging step
        if: ${{ inputs.enable_ssh_debugging == true }} # Only run when debugging is enabled
        run: |
          mkdir -p ~/.ssh
          # Create SSH directory if it doesn't exist
          echo "${{ secrets.DO_SSH_KEY }}" > ~/.ssh/id_ed25519
          # Create private SSH key file
          chmod 600 ~/.ssh/id_ed25519
          # Set secure permissions on the key
          echo "${{ secrets.DO_HOST_KEY }}" >> ~/.ssh/known_hosts
          # Add host key to known hosts
          ssh-keygen -l -f ~/.ssh/id_ed25519
          # Show fingerprint of the key
          ssh-keygen -y -f ~/.ssh/id_ed25519
          # Show public key derived from private key
          ssh -vvv -o StrictHostKeyChecking=accept-new -o BatchMode=yes -i ~/.ssh/id_ed25519 ${{ secrets.DO_USERNAME }}@${{ secrets.DO_TAILSCALE_NAME }} 'echo "Connection successful"'
          # Test connection with verbose output

      # Step 3: Create .env File Locally
      - name: Create .env File on Server # Create environment file for deployment
        run: |
          cat > envfile <<EOF
          # Start heredoc to create env file
          # -------- PostgreSQL Config
          # Database username
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          # Database password
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          # Database name
          POSTGRES_DB=${{ vars.POSTGRES_DB }}
          # Container hostname for database
          POSTGRES_HOST=${{ vars.POSTGRES_HOST }}
          # Database port
          POSTGRES_PORT=${{ vars.POSTGRES_PORT }}
          # Database schema
          POSTGRES_SCHEMA=${{ vars.POSTGRES_SCHEMA }}
          POSTGRES_SSL_ROOT_CERT=${{ secrets.POSTGRES_SSL_ROOT_CERT }}
          # Database connection options, hardcoded intentionally
          POSTGRES_OPTIONS=sslmode=verify-full&sslrootcert=/app/root.crt
          # Database connection string
          DATABASE_URL=postgres://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@${{ vars.POSTGRES_HOST }}:${{ vars.POSTGRES_PORT }}/${{ vars.POSTGRES_DB }}?${{ vars.POSTGRES_OPTIONS }}

          # -------- Backend Config
          # Docker image for backend
          BACKEND_IMAGE_NAME=${{ vars.BACKEND_IMAGE_NAME }}
          # Container name for backend
          BACKEND_CONTAINER_NAME=${{ vars.BACKEND_CONTAINER_NAME }}
          # We are not building locally so setting to empty string to quiet warning
          BACKEND_BUILD_CONTEXT=""
          # Backend daemon port used by the Rust backend to listen to connection on
          BACKEND_PORT=${{ vars.BACKEND_PORT }}
          # Network interface for backend to listen for incoming connections on
          BACKEND_INTERFACE=${{ vars.BACKEND_INTERFACE }}
          # CORS allowed origins
          BACKEND_ALLOWED_ORIGINS=${{ vars.BACKEND_ALLOWED_ORIGINS }}
          # Logging filter level to apply
          BACKEND_LOG_FILTER_LEVEL=${{ vars.BACKEND_LOG_FILTER_LEVEL }}
          # Protocol for backend (http, https)
          BACKEND_SERVICE_PROTOCOL=${{ vars.BACKEND_SERVICE_PROTOCOL }}
          # Hostname or IP address to reach the backend on
          BACKEND_SERVICE_HOST=${{ vars.BACKEND_SERVICE_HOST }}
          # Backend service port used by the frontend / reverse proxy
          BACKEND_SERVICE_PORT=${{ vars.BACKEND_SERVICE_PORT }}
          # The URL path to proxy the backend API on (e.g. "api" would resolve to https://backend/api/)
          BACKEND_SERVICE_API_PATH=${{ vars.BACKEND_SERVICE_API_PATH }}
          # API version to use between frontend and backend
          BACKEND_API_VERSION=${{ vars.BACKEND_API_VERSION }}
          # Deployment environment used (development, staging, production)
          RUST_ENV=${{ vars.RUST_ENV }}

          # -------- TipTap Config
          # TipTap account unique ID
          TIPTAP_APP_ID=${{ vars.TIPTAP_APP_ID }}
          # TipTap collaborative editor URL
          TIPTAP_URL=${{ secrets.TIPTAP_URL }}
          # TipTap authentication key
          TIPTAP_AUTH_KEY=${{ secrets.TIPTAP_AUTH_KEY }}
          # JWT signing key for TipTap
          TIPTAP_JWT_SIGNING_KEY=${{ secrets.TIPTAP_JWT_SIGNING_KEY }}

          # -------- Frontend Config
          # Docker image for frontend
          FRONTEND_IMAGE_NAME=${{ vars.FRONTEND_IMAGE_NAME }}
          # Container name for frontend
          FRONTEND_CONTAINER_NAME=${{ vars.FRONTEND_CONTAINER_NAME }}
          # We are not building locally so setting to empty string to quiet warning
          FRONTEND_BUILD_CONTEXT=""
          # Frontend service interface to listen for client connections on
          FRONTEND_SERVICE_INTERFACE=${{ vars.FRONTEND_SERVICE_INTERFACE }}
          # Frontend service port
          FRONTEND_SERVICE_PORT=${{ vars.FRONTEND_SERVICE_PORT }}

          # -------- Nginx Reverse Proxy Config
          SSL_DHPARAMS_PATH=${{ vars.SSL_DHPARAMS_PATH }}

          # -------- Platform Config
          # Target platform for Docker containers
          PLATFORM=${{ vars.PLATFORM }}

          EOF

      # Step 4: SSH and deploy to the digitalocean droplet over private Tailscale tailnet
      - name: Deploy Over SSH to Server and Restart Service # Main deployment step
        run: |
          mkdir -p ~/.ssh
          # Create SSH directory
          echo "${{ secrets.DO_SSH_KEY }}" > ~/.ssh/id_ed25519
          # Save SSH private key
          chmod 600 ~/.ssh/id_ed25519
          # Set secure permissions on key
          echo "${{ secrets.DO_HOST_KEY }}" >> ~/.ssh/known_hosts
          # Add static host key
          ssh-keyscan -H ${{ secrets.DO_TAILSCALE_NAME }} >> ~/.ssh/known_hosts
          # Add dynamic host key

          # Copy .env to server
          scp -o StrictHostKeyChecking=accept-new -i ~/.ssh/id_ed25519 envfile ${{ secrets.DO_USERNAME }}@${{ secrets.DO_TAILSCALE_NAME }}:/home/deploy/.env
          # Upload env file

          # SSH and deploy
          ssh -o StrictHostKeyChecking=accept-new -o BatchMode=yes -i ~/.ssh/id_ed25519 ${{ secrets.DO_USERNAME }}@${{ secrets.DO_TAILSCALE_NAME }} '
            set -e
            # Exit immediately if any command fails


            # Cleanup function to ensure service gets restarted even on failure
            cleanup() {
              echo "INFO: ğŸ”„ Ensuring Refactor Platform service is running..."
              if systemctl list-unit-files | grep -q "refactor-platform.service"; then
                sudo systemctl start refactor-platform.service 2>/dev/null || echo "WARNING: Failed to restart service"
              else
                echo "WARNING: refactor-platform.service not found during cleanup"
              fi
            }

            # CRITICAL: Verify we're running on the target server, not GitHub Actions runner
            echo "===== SSH CONNECTION DIAGNOSTICS ====="
            echo "DEBUG: Hostname: $(hostname)"
            echo "DEBUG: Current user: $(whoami)"
            echo "DEBUG: Home directory: $HOME"
            echo "DEBUG: Current working directory: $(pwd)"
            echo "DEBUG: Available disk space:"
            df -h / | head -2
            echo "DEBUG: Network interfaces:"
            ip addr show | grep -E "inet|UP" | head -5
            echo "========================================="

            # Verify we're on the target server (not GitHub Actions runner)
            if [[ "$(hostname)" == *"runner"* ]] || [[ "$(pwd)" == *"runner"* ]]; then
                echo "FATAL ERROR: Script is running on GitHub Actions runner instead of target server!"
                echo "SSH connection failed - aborting deployment"
                exit 1
            fi

            echo 'INFO: ğŸ“¦ Starting deployment from branch: ${{ github.ref_name }}...'
            
            # Ensure we're in the correct directory
            cd /home/deploy || { 
                echo "FATAL ERROR: Cannot change to /home/deploy directory"
                echo "Current directory: $(pwd)"
                echo "Directory contents:"
                ls -la
                exit 1
            }
            curl -O https://raw.githubusercontent.com/refactor-group/refactor-platform-rs/refs/heads/${{ github.ref_name }}/docker-compose.yaml
            if [ -f docker-compose.yaml ]; then
                chmod 640 docker-compose.yaml
            else
                echo "ERROR: Failed to download docker-compose.yaml"
                exit 1
            fi

            # Check if docker-compose.yaml exists before using it as reference
            if [ ! -f docker-compose.yaml ]; then
                echo "ERROR: docker-compose.yaml not found - cannot set permissions"
                exit 1
            fi

            echo "INFO: ğŸ›‘ Stopping Refactor Platform service before nginx setup..."
            sudo systemctl stop refactor-platform.service
            
            echo "INFO: Creating nginx directories..."
            if ! mkdir -p nginx/conf.d nginx/logs nginx/scripts nginx/html/.well-known/acme-challenge; then
              echo "ERROR: Failed to create nginx directories"
              exit 1
            fi

            # Debug: Verify all directories were created
            echo "DEBUG: Checking created directories:"
            ls -la nginx/
            echo "DEBUG: Checking scripts directory specifically:"
            ls -la nginx/scripts/ || echo "DEBUG: scripts directory missing"

            echo "INFO: Setting initial directory permissions..."
            # Ensure current user owns the nginx directory tree
            chown -R $(whoami):$(whoami) nginx/ 2>/dev/null || true
            echo "DEBUG: Before chmod - checking scripts directory:"
            ls -la nginx/scripts/ || echo "DEBUG: scripts directory missing before chmod"
            # Set restrictive directory permissions initially
            find nginx -type d -exec chmod 755 {} \;
            echo "DEBUG: After chmod - checking scripts directory:"
            ls -la nginx/scripts/ || echo "DEBUG: scripts directory missing after chmod"

            echo "INFO: Downloading nginx configuration files..."

            # COMPREHENSIVE DEBUGGING - Remove after issue is resolved
            echo "=================== COMPREHENSIVE DEBUG START ==================="
            echo "DEBUG: Current working directory: $(pwd)"
            echo "DEBUG: Current user: $(whoami)"
            echo "DEBUG: Current groups: $(groups)"
            echo "DEBUG: Available disk space:"
            df -h . | head -2
            echo "DEBUG: Complete nginx structure before downloads:"
            find nginx -ls 2>/dev/null || echo "DEBUG: find command failed"
            echo "DEBUG: Running processes that might interfere:"
            ps aux | grep -E "(nginx|docker|systemd)" | head -10
            echo "DEBUG: Docker container status:"
            docker ps -a 2>/dev/null | head -5 || echo "DEBUG: Docker not accessible"
            echo "DEBUG: Mount points that could affect nginx directory:"
            mount | grep -E "(nginx|/home)" || echo "DEBUG: No relevant mounts found"
            echo "DEBUG: File system type:"
            df -T . | tail -1
            echo "DEBUG: Testing directory stability with delay:"
            ls -la nginx/scripts/ || echo "DEBUG: scripts missing at checkpoint 1"
            sleep 1
            ls -la nginx/scripts/ || echo "DEBUG: scripts missing at checkpoint 2"  
            echo "DEBUG: Attempting to recreate scripts directory:"
            mkdir -p nginx/scripts
            ls -la nginx/scripts/ || echo "DEBUG: Failed to recreate scripts directory"
            echo "DEBUG: Testing file creation in scripts:"
            touch nginx/scripts/debug-test.txt 2>/dev/null && echo "DEBUG: File creation successful" || echo "DEBUG: File creation failed"
            ls -la nginx/scripts/
            echo "=================== COMPREHENSIVE DEBUG END ==================="

            # FINAL DEBUG: Monitor what happens in the critical moment
            echo "DEBUG: Starting critical monitoring..."
            ls -la nginx/scripts/ || echo "DEBUG: scripts missing before monitoring"
            
            # Monitor background processes during this critical window
            (ps aux | grep -E "(logrotate|cron|systemd)" | head -5) &
            
            # Check for any systemd timers or services that might interfere
            echo "DEBUG: Active systemd timers:"
            systemctl list-timers --all 2>/dev/null | grep -E "(nginx|log|clean)" | head -3 || echo "DEBUG: No relevant timers"
            
            echo "DEBUG: Checking for file watchers or background processes:"
            lsof /home/deploy/nginx 2>/dev/null | head -5 || echo "DEBUG: No processes have nginx directory open"
            
            # One final check right before download
            echo "DEBUG: Final directory check:"
            ls -la nginx/scripts/ || echo "DEBUG: scripts missing at final check"

            # Download main nginx config
            if ! curl -fsSL "https://raw.githubusercontent.com/refactor-group/refactor-platform-rs/refs/heads/${{ github.ref_name }}/nginx/nginx.conf" -o nginx/nginx.conf; then
                echo "ERROR: Failed to download nginx.conf"
                exit 1
            fi

            # Verify the main nginx config file was downloaded and is not empty
            if [ ! -s nginx/nginx.conf ]; then
                echo "ERROR: Downloaded nginx.conf is empty or could not be created"
                exit 1
            fi

            # Download refactor platform nginx reverse proxy config
            if ! curl -fsSL "https://raw.githubusercontent.com/refactor-group/refactor-platform-rs/refs/heads/${{ github.ref_name }}/nginx/conf.d/refactor-platform.conf" -o nginx/conf.d/refactor-platform.conf; then
                echo "ERROR: Failed to download refactor-platform.conf"
                exit 1
            fi

            # Verify the platform config file was downloaded and is not empty
            if [ ! -s nginx/conf.d/refactor-platform.conf ]; then
                echo "ERROR: Downloaded refactor-platform.conf is empty or could not be created"
                exit 1
            fi

            # Download refactor platform nginx let's encrypt ssl cert renewal script
            # Handle potential directory issues with robust retry logic
            echo "DEBUG: Preparing to download renew-certs.sh..."
            
            # Ensure scripts directory exists (recreate if needed)
            if [ ! -d nginx/scripts ]; then
                echo "DEBUG: Scripts directory missing, recreating..."
                mkdir -p nginx/scripts
            fi
            
            # Remove existing file first to avoid permission issues
            rm -f nginx/scripts/renew-certs.sh 2>/dev/null || true
            
            # Download with retry if directory disappears
            if ! curl -fsSL "https://raw.githubusercontent.com/refactor-group/refactor-platform-rs/refs/heads/${{ github.ref_name }}/nginx/scripts/renew-certs.sh" -o nginx/scripts/renew-certs.sh; then
                echo "DEBUG: First download attempt failed, recreating directory and retrying..."
                mkdir -p nginx/scripts
                if ! curl -fsSL "https://raw.githubusercontent.com/refactor-group/refactor-platform-rs/refs/heads/${{ github.ref_name }}/nginx/scripts/renew-certs.sh" -o nginx/scripts/renew-certs.sh; then
                    echo "ERROR: Failed to download renew-certs.sh after retry"
                    exit 1
                fi
            fi

            # Verify the renew certs script file was downloaded and is not empty
            if [ ! -s nginx/scripts/renew-certs.sh ]; then
                echo "ERROR: Downloaded renew-certs.sh script is empty or could not be created"
                exit 1
            fi

            if [ -f nginx/scripts/renew-certs.sh ]; then
                chmod 770 nginx/scripts/renew-certs.sh
            else
                echo "WARNING: renew-certs.sh not found for initial chmod"
            fi

            echo "INFO: Setting final directory permissions..."
            # Set final directory permissions to allow group write access
            if [ -d nginx ]; then
                find nginx -type d -exec chmod 770 {} \;
                # Set file permissions for downloaded files
                find nginx -type f -exec chmod 660 {} \; 2>/dev/null || true
                # Make the renewal script executable
                if [ -f nginx/scripts/renew-certs.sh ]; then
                    chmod 770 nginx/scripts/renew-certs.sh
                else
                    echo "WARNING: renew-certs.sh not found for final chmod"
                fi
            else
                echo "WARNING: nginx directory not found for final permissions"
            fi

            echo "INFO: Nginx setup completed successfully!"

            # Now set trap to ensure service restart on any subsequent failure  
            trap 'echo "INFO: ğŸ”„ Ensuring Refactor Platform service is running..."; if systemctl list-unit-files | grep -q "refactor-platform.service"; then sudo systemctl start refactor-platform.service 2>/dev/null || echo "WARNING: Failed to restart service"; else echo "WARNING: refactor-platform.service not found during cleanup"; fi' EXIT

            echo "INFO: ğŸ”§ Matching .env permissions to docker-compose.yaml..."
            # Update env file permissions
            # Copy permissions from compose file
            if [ -f docker-compose.yaml ] && [ -f .env ]; then
                chmod --reference=docker-compose.yaml .env
                # Copy ownership from compose file
                chown --reference=docker-compose.yaml .env
            elif [ -f .env ]; then
                echo "WARNING: docker-compose.yaml not found, setting default .env permissions"
                chmod 640 .env
            else
                echo "WARNING: .env file not found, skipping permission setting"
            fi

            echo "INFO: ğŸ“¥ Logging into GHCR..."
            # Login to GitHub Container Registry
            echo ${{ secrets.GHCR_PAT }} | docker login ghcr.io -u ${{ secrets.GHCR_USERNAME }} --password-stdin
            # Docker login

            echo "INFO: ğŸ“¥ Pulling images..."
            # Pull Docker images
            if [ -n "${{ vars.BACKEND_IMAGE_NAME }}" ]; then
              # Check if backend image is set
              echo "INFO: Pulling backend image: ${{ vars.BACKEND_IMAGE_NAME }}"
              # Announce image pull
              docker pull ${{ vars.BACKEND_IMAGE_NAME }}
              # Pull backend image
            fi
            if [ -n "${{ vars.FRONTEND_IMAGE_NAME }}" ]; then
              # Check if frontend image is set
              echo "INFO: Pulling frontend image: ${{ vars.FRONTEND_IMAGE_NAME }}"
              # Announce image pull
              docker pull ${{ vars.FRONTEND_IMAGE_NAME }}
              # Pull frontend image
            fi

            echo "INFO: ğŸ” Validating config..."
            # Verify docker-compose configuration
            echo "DEBUG: Current directory: $(pwd)"
            echo "DEBUG: Files in current directory:"
            ls -la *.yaml 2>/dev/null || echo "No YAML files found"
            if [ -f docker-compose.yaml ]; then
                docker compose config --quiet
            else
                echo "WARNING: docker-compose.yaml not found, skipping config validation"
            fi
            # Check config without output unless error

            echo "INFO: ğŸš€ Starting Refactor Platform service..."
            
            # Verify systemd service exists before attempting to start
            if systemctl list-unit-files | grep -q "refactor-platform.service"; then
                echo "DEBUG: refactor-platform.service found"
                sudo systemctl start refactor-platform.service
            else
                echo "ERROR: refactor-platform.service not found"
                echo "DEBUG: Available services matching 'refactor':"
                systemctl list-unit-files | grep -i refactor || echo "No refactor services found"
                echo "DEBUG: All systemd service files:"
                systemctl list-unit-files | head -10
                exit 1
            fi

            echo "INFO: â³ Waiting for startup..."
            # Wait for containers to reach steady state
            sleep 3

            echo "INFO: ğŸ©º Checking service and status..."
            systemctl status refactor-platform.service
            # Check container status
            docker ps -a
            # List all containers

            echo "INFO: ğŸ©º Verifying app status..."
            # Verify application health
            echo "INFO: ğŸ©º Checking rust-app service status..."
            if docker ps | grep -q rust-app; then
              echo "INFO: âœ… Deployment succeeded! rust-app is running."
            else
              echo "ERROR: âš ï¸ Missing container for rust-app. Logs follow:"
              # Show backend logs
              docker logs rust-app --tail 30 2>/dev/null || echo "âŒ Backend logs unavailable"
            fi

            echo "INFO: ğŸ‰ Deployment complete."
            # Final deployment message
          '

name: Build and Push Non-Production Images

# Set default permissions as restrictive as possible
permissions:
  contents: read

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch: # Allow manual triggering

env:
  CARGO_TERM_COLOR: always # Enable colored Cargo output
  REGISTRY: ghcr.io # Container registry
  BASE_REPO: ${{ github.repository }} # Base repository name

jobs:
  code-quality:
    name: Code Tests & Linting # First job - validate code quality
    runs-on: ubuntu-latest # Use latest Ubuntu LTS
    outputs:
      branch_name: ${{ steps.branch_info.outputs.branch_name }} # Export branch name for other jobs
      image_name: ${{ steps.set-outputs.outputs.image_name }} # Export full image name
      
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4 # Use latest checkout action
        with:
          fetch-depth: 0 # Full history for better versioning

      - name: Extract branch info # Get branch name for image naming
        id: branch_info
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          # Replace slashes with dashes for Docker compatibility
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/\//-/g')
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Detected branch: ${BRANCH_NAME}"
      
      - name: Generate image name with branch # Create full image name with branch
        id: image_name
        run: |
          # Append branch name to base repository name
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.BASE_REPO }}-${{ steps.branch_info.outputs.branch_name }}"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "Full image name: ${IMAGE_NAME}"
      
      - name: Set up Rust toolchain # Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt # Install components in one step
          targets: x86_64-unknown-linux-gnu,aarch64-unknown-linux-gnu # For multi-arch

      - name: Set OpenSSL paths # Configure OpenSSL for native builds
        run: |
          echo "OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include/x86_64-linux-gnu" >> $GITHUB_ENV

      # OPTIMIZATION: Enhanced Rust Caching
      - name: Cache dependencies # Use Swatinem/rust-cache for efficient caching
        uses: Swatinem/rust-cache@v2
        with:
          key: "v1-cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}" # Hash-based cache key
          shared-key: "rust-cache-${{ runner.os }}"
          save-if: true # Always save cache
          cache-targets: true # Cache compiled artifacts
          cache-on-failure: true # Cache even when builds fail
          cache-directories: |
            ~/.cargo/git
            ~/.cargo/registry

      - name: Install seaORM CLI # Install database tools
        uses: taiki-e/install-action@v2 # Faster installation than cargo install
        with:
          tool: sea-orm-cli

      - name: Build # Build all targets for testing
        run: cargo build --all-targets

      - name: Run tests # Run the test suite
        run: cargo test

      - name: Run clippy # Static code analysis
        run: cargo clippy -- -Dwarnings

      - name: Verify formatting # Code style check
        run: cargo fmt --check

      - name: Set outputs
        id: set-outputs
        run: echo "image_name=${{ steps.image_name.outputs.image_name }}" >> $GITHUB_OUTPUT
        
  container-build:
    name: Build & Push Container # Second job - build and push container images
    runs-on: ubuntu-24.04
    needs: code-quality # Only run if tests pass
    if: ${{ success() }} # Always run when tests succeed
    outputs:
      image_uri: ${{ needs.code-quality.outputs.image_name }}:stable # Pass image URI to next job
      image_digest: ${{ steps.docker_build.outputs.digest }} # Pass image digest to next job
    
    permissions:
      contents: read      # To check out code
      packages: write     # To push to container registry (if using GitHub Packages)
      id-token: write     # For registry authentication (if using OIDC)
    
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4

      # OPTIMIZATION: BuildKit Optimization Options
      - name: Set up Docker Buildx # Set up enhanced Docker builder
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["mirror.gcr.io"]

      # Set up QEMU # Set up emulation for multi-arch builds
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Login to GitHub Container Registry # Authenticate with registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata and prepare tags - always using "stable" tag
      - name: Extract Docker metadata # Create tags and labels
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.code-quality.outputs.image_name }}
          tags: |
            type=raw,value=stable
            type=sha,format=long

      # OPTIMIZATION: Multi-level Registry Caching for Docker
      - name: Build and push # Focus only on building and pushing
        id: docker_build
        continue-on-error: true  # Allow step to complete even if cache export fails
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          cache-from: type=registry,ref=${{ needs.code-quality.outputs.image_name || 'ghcr.io/refactor-group/refactor-platform-rs' }}:cache
          cache-to: |
            type=registry,ref=${{ needs.code-quality.outputs.image_name }}:cache,mode=max,image-manifest=true,oci-mediatypes=true,ignore-error=true
          outputs: type=image,compression=zstd,compression-level=3,force-compression=true
          provenance: true
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # Verify the image was actually pushed despite any cache errors
      - name: Verify image was pushed successfully
        id: verify_image
        run: |
          IMAGE="${{ needs.code-quality.outputs.image_name }}:stable"
          echo "Verifying image: $IMAGE"
          for i in {1..3}; do
            echo "Attempt $i to pull image..."
            if docker pull $IMAGE; then
              echo "✅ Image successfully built and pushed"
              DIGEST=$(docker inspect $IMAGE --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
              echo "image_digest=$DIGEST" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "❌ Failed to verify image. Build may have failed."
          exit 1

      # Use the verified digest for output
      - name: Image build summary
        run: |
          echo "✅ Multi-arch container image built and pushed"
          echo "📦 Image: ${{ needs.code-quality.outputs.image_name }}:stable"
          echo "🏷️ Digest: ${{ steps.verify_image.outputs.image_digest }}"
        if: steps.verify_image.outcome == 'success'
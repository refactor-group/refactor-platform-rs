name: Build and Push Non-Production Images

# Set default permissions as restrictive as possible
permissions:
  contents: read

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch: # Allow manual triggering

env:
  CARGO_TERM_COLOR: always # Enable colored Cargo output
  REGISTRY: ghcr.io # Container registry
  BASE_REPO: ${{ github.repository }} # Base repository name

jobs:
  code-quality:
    name: Code Tests & Linting # First job - validate code quality
    runs-on: ubuntu-latest # Use latest Ubuntu LTS
    outputs:
      branch_name: ${{ steps.branch_info.outputs.branch_name }} # Export branch name for other jobs
      image_name: ${{ steps.set-outputs.outputs.image_name }} # Export full image name
      
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4 # Use latest checkout action
        with:
          fetch-depth: 0 # Full history for better versioning

      - name: Extract branch info # Get branch name for image naming
        id: branch_info
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          # Replace slashes with dashes for Docker compatibility
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/\//-/g')
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Detected branch: ${BRANCH_NAME}"
      
      - name: Generate image name with branch # Create full image name with branch
        id: image_name
        run: |
          # Append branch name to base repository name
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.BASE_REPO }}-${{ steps.branch_info.outputs.branch_name }}"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "Full image name: ${IMAGE_NAME}"
      
      - name: Set up Rust toolchain # Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt # Install components in one step
          targets: x86_64-unknown-linux-gnu,aarch64-unknown-linux-gnu # For multi-arch

      - name: Set OpenSSL paths # Configure OpenSSL for native builds
        run: |
          echo "OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include/x86_64-linux-gnu" >> $GITHUB_ENV

      # OPTIMIZATION: Enhanced Rust Caching
      - name: Cache dependencies # Use Swatinem/rust-cache for efficient caching
        uses: Swatinem/rust-cache@v2
        with:
          key: "v1-cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}" # Hash-based cache key
          shared-key: "rust-cache-${{ runner.os }}"
          save-if: true # Always save cache
          cache-targets: true # Cache compiled artifacts
          cache-on-failure: true # Cache even when builds fail
          cache-directories: |
            ~/.cargo/git
            ~/.cargo/registry

      - name: Install seaORM CLI # Install database tools
        uses: taiki-e/install-action@v2 # Faster installation than cargo install
        with:
          tool: sea-orm-cli

      - name: Build # Build all targets for testing
        run: cargo build --all-targets

      - name: Run tests # Run the test suite
        run: cargo test

      - name: Run clippy # Static code analysis
        run: cargo clippy -- -Dwarnings

      - name: Verify formatting # Code style check
        run: cargo fmt --check

      - name: Set outputs
        id: set-outputs
        run: echo "image_name=${{ steps.image_name.outputs.image_name }}" >> $GITHUB_OUTPUT
        
  container-build:
    name: Build & Push Container # Second job - build and push container images
    runs-on: ubuntu-24.04
    needs: code-quality # Only run if tests pass
    if: ${{ success() }} # Always run when tests succeed
    outputs:
      image_uri: ${{ needs.code-quality.outputs.image_name }}:stable # Pass image URI to next job
      image_digest: ${{ steps.docker_build.outputs.digest }} # Pass image digest to next job
    
    permissions:
      contents: read      # To check out code
      packages: write     # To push to container registry (if using GitHub Packages)
      id-token: write     # For registry authentication (if using OIDC)
    
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4

      # OPTIMIZATION: BuildKit Optimization Options
      - name: Set up Docker Buildx # Set up enhanced Docker builder
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["mirror.gcr.io"]

      # Set up QEMU # Set up emulation for multi-arch builds
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Login to GitHub Container Registry # Authenticate with registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata and prepare tags - always using "stable" tag
      - name: Extract Docker metadata # Create tags and labels
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.code-quality.outputs.image_name }}
          tags: |
            type=raw,value=stable
            type=sha,format=long

      # OPTIMIZATION: Multi-level Registry Caching for Docker
      - name: Build and push # Focus only on building and pushing
        id: docker_build
        continue-on-error: true  # Allow step to complete even if cache export fails
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          cache-from: type=registry,ref=${{ needs.code-quality.outputs.image_name || 'ghcr.io/refactor-group/refactor-platform-rs' }}:cache
          cache-to: |
            type=registry,ref=${{ needs.code-quality.outputs.image_name }}:cache,mode=max,image-manifest=true,oci-mediatypes=true,ignore-error=true
          outputs: type=image,compression=zstd,compression-level=3,force-compression=true
          provenance: true
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # Verify the image was actually pushed despite any cache errors
      - name: Verify image was pushed successfully
        id: verify_image
        run: |
          IMAGE="${{ needs.code-quality.outputs.image_name }}:stable"
          echo "Verifying image: $IMAGE"
          for i in {1..3}; do
            echo "Attempt $i to pull image..."
            if docker pull $IMAGE; then
              echo "‚úÖ Image successfully built and pushed"
              DIGEST=$(docker inspect $IMAGE --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
              echo "image_digest=$DIGEST" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "‚ùå Failed to verify image. Build may have failed."
          exit 1

      # Use the verified digest for output
      - name: Image build summary
        run: |
          echo "‚úÖ Multi-arch container image built and pushed"
          echo "üì¶ Image: ${{ needs.code-quality.outputs.image_name }}:stable"
          echo "üè∑Ô∏è Digest: ${{ steps.verify_image.outputs.image_digest }}"
        if: steps.verify_image.outcome == 'success'

  security-scan:
      name: Security Scanning & Signing
      runs-on: ubuntu-24.04
      needs: [code-quality, container-build]
      if: ${{ success() }}
      
      permissions:
        contents: read
        packages: read
        id-token: write
        security-events: write
      
      steps:
        - name: Login to GitHub Container Registry
          uses: docker/login-action@v3
          with:
            registry: ${{ env.REGISTRY }}
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}

        - name: Pull image with retry logic
          id: pull_image
          run: |
            IMAGE="${{ needs.code-quality.outputs.image_name }}:stable"
            echo "image=$IMAGE" >> $GITHUB_OUTPUT
            
            # Try pulling with retry logic instead of fixed sleep
            for i in {1..5}; do
              echo "Attempt $i to pull $IMAGE..."
              if docker pull $IMAGE; then
                echo "‚úÖ Successfully pulled image on attempt $i"
                docker images
                exit 0
              fi
              echo "Pull failed, waiting before retry..."
              sleep 20
            done
            
            echo "::warning::Failed to pull image after multiple attempts, but continuing workflow"
            exit 0  # Continue workflow even if pull fails
          
        # Security scanning with Trivy - unchanged but with explicit continue-on-error
        - name: Cache Trivy vulnerability database
          uses: actions/cache@v3
          with:
            path: ~/.cache/trivy
            key: trivy-${{ runner.os }}-${{ github.run_id }}
            restore-keys: |
              trivy-${{ runner.os }}-
              
        - name: Run Trivy vulnerability scanner
          continue-on-error: true  # Don't fail workflow on vulnerabilities
          id: trivy_scan
          uses: aquasecurity/trivy-action@master
          with:
            image-ref: ${{ steps.pull_image.outputs.image }}
            format: 'sarif'
            output: 'trivy-results.sarif'
            severity: 'CRITICAL,HIGH'
            timeout: '10m'
            cache-dir: ~/.cache/trivy

        - name: Upload Trivy scan results
          uses: github/codeql-action/upload-sarif@v3
          if: always()  # Always try to upload results
          continue-on-error: true  # Don't fail if upload fails
          with:
            sarif_file: 'trivy-results.sarif'
            category: 'trivy'

        - name: Install cosign
          uses: sigstore/cosign-installer@v3.4.0
          with:
            cosign-release: 'v2.2.3'

        - name: Sign the container image
          id: sign_image
          continue-on-error: true  # Don't fail workflow if signing fails
          run: |
            IMAGE="${{ steps.pull_image.outputs.image }}"
            if ! cosign sign --yes ${IMAGE}; then
              echo "::warning::Image signing failed, but continuing workflow"
              echo "signed=false" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ Image signed: ${IMAGE}"
              echo "signed=true" >> $GITHUB_OUTPUT
            fi

        - name: Print deployment information
          run: |
            echo "::group::üìã Deployment Information"
            echo "‚úÖ Image processing completed!"
            echo ""
            echo "üöÄ Image Details:"
            echo "   - Full Image Name: ${{ needs.code-quality.outputs.image_name }}:stable"
            echo "   - Registry: ${{ env.REGISTRY }}"
            echo "   - Repository: ${{ env.BASE_REPO }}-${{ needs.code-quality.outputs.branch_name }}"
            echo "   - Tag: stable"
            echo "   - Supported Architectures: linux/amd64, linux/arm64"
            echo "   - Image Digest: ${{ needs.container-build.outputs.image_digest }}"
            echo ""
            echo "üõ°Ô∏è Security Features:"
            echo "   - Trivy vulnerability scanning completed"
            if [[ "${{ steps.sign_image.outputs.signed }}" == "true" ]]; then
              echo "   - ‚úÖ Image signed with Cosign"
            else
              echo "   - ‚ö†Ô∏è Image signing skipped or failed"
            fi
            echo ""          
            echo "üì¶ To pull this image:"
            echo "   docker pull ${{ needs.code-quality.outputs.image_name }}:stable"
            echo ""
            echo "üöÄ To deploy with docker-compose:"
            echo "   Update your .env file with:"
            echo "   BACKEND_IMAGE_NAME=${{ needs.code-quality.outputs.image_name }}:stable"
            echo "   Then run: docker-compose up -d"
            echo "::endgroup::"
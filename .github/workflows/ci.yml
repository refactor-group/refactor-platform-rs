name: Build and Push Non-Production Images

# Restrictive default permissions for security
permissions:
  contents: read

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch:  # Allow manual trigger

env:
  CARGO_TERM_COLOR: always  # Enable colored output in Cargo logs
  REGISTRY: ghcr.io         # GitHub Container Registry domain
  BASE_REPO: ${{ github.repository }}  # Full repository name (e.g., org/repo)

jobs:
  # ---------------------- CODE QUALITY JOB ----------------------
  code-quality:
    name: Code Tests & Linting
    runs-on: ubuntu-latest
    outputs:
      branch_name: ${{ steps.branch_info.outputs.branch_name }}
      image_name: ${{ steps.set-outputs.outputs.image_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for full commit/branch history

      - name: Extract branch info
        id: branch_info
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/\//-/g')
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT

      - name: Generate image name with branch
        id: image_name
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.BASE_REPO }}-${{ steps.branch_info.outputs.branch_name }}"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt
          targets: x86_64-unknown-linux-gnu,aarch64-unknown-linux-gnu

      - name: Set OpenSSL paths
        run: |
          echo "OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include/x86_64-linux-gnu" >> $GITHUB_ENV

      - name: Cache dependencies
        uses: Swatinem/rust-cache@v2
        with:
          key: "v1-cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}"
          shared-key: "rust-cache-${{ runner.os }}"
          save-if: true
          cache-targets: true
          cache-on-failure: true
          cache-directories: |
            ~/.cargo/git
            ~/.cargo/registry

      - name: Install seaORM CLI
        uses: taiki-e/install-action@v2
        with:
          tool: sea-orm-cli

      - name: Build all targets
        run: cargo build --all-targets

      - name: Run tests
        run: cargo test

      - name: Lint with clippy
        run: cargo clippy -- -Dwarnings

      - name: Check code formatting
        run: cargo fmt --check

      - name: Set outputs for next jobs
        id: set-outputs
        run: echo "image_name=${{ steps.image_name.outputs.image_name }}" >> $GITHUB_OUTPUT

  # ---------------------- BUILD & PUSH JOB ----------------------
  container-build:
    name: Build & Push Container
    runs-on: ubuntu-24.04
    needs: code-quality
    if: ${{ success() }}
    outputs:
      image_uri: ${{ needs.code-quality.outputs.image_name }}:stable
      image_digest: ${{ steps.verify_image.outputs.image_digest }}

    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up QEMU (multi-arch)
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Local cache fallback to improve cache reliability
      - name: Cache Docker layers (local fallback)
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: docker-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            docker-${{ runner.os }}-

      - name: Generate Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.code-quality.outputs.image_name }}
          tags: |
            type=raw,value=stable
            type=sha,format=long

      - name: Build and push image with caching
        id: docker_build
        continue-on-error: true  # Prevent cache upload errors from breaking build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          # Use branch-specific registry cache and local fallback
          cache-from: |
            type=registry,ref=${{ needs.code-quality.outputs.image_name }}-cache
            type=local,src=/tmp/.buildx-cache
          # Export only metadata to registry to avoid EOF errors
          cache-to: |
            type=registry,ref=${{ needs.code-quality.outputs.image_name }}-cache,mode=max,image-manifest=true,oci-mediatypes=true,ignore-error=true
            type=local,dest=/tmp/.buildx-cache
          outputs: type=image,compression=zstd,compression-level=3,force-compression=true
          provenance: true
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify image was pushed successfully
        id: verify_image
        run: |
          IMAGE="${{ needs.code-quality.outputs.image_name }}:stable"
          for i in {1..3}; do
            if docker pull $IMAGE; then
              DIGEST=$(docker inspect $IMAGE --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
              echo "image_digest=$DIGEST" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "❌ Failed to verify image. Build may have failed."
          exit 1

      - name: Print image summary
        run: |
          echo "✅ Image built and pushed"
          echo "📦 ${{ needs.code-quality.outputs.image_name }}:stable"
          echo "🔖 Digest: ${{ steps.verify_image.outputs.image_digest }}"
        if: steps.verify_image.outcome == 'success'

  # ---------------------- SECURITY & SIGNING JOB ----------------------
  security-scan:
    name: Security Scanning & Signing
    runs-on: ubuntu-24.04
    needs: [code-quality, container-build]
    if: ${{ success() }}
    
    permissions:
      contents: read
      packages: write  # Changed from 'read' to 'write' for signature uploads
      id-token: write
      security-events: write
    
    steps:
      - name: Checkout repository  # Add this missing checkout step
        uses: actions/checkout@v4
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image with retries
        id: pull_image
        run: |
          IMAGE="${{ needs.code-quality.outputs.image_name }}:stable"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          for i in {1..5}; do
            if docker pull $IMAGE; then
              exit 0
            fi
            sleep 20
          done
          echo "::warning::Failed to pull image after retries"
          exit 0

      - name: Cache Trivy database
        uses: actions/cache@v3
        with:
          path: ~/.cache/trivy
          key: trivy-${{ runner.os }}-${{ github.run_id }}
          restore-keys: |
            trivy-${{ runner.os }}-

      - name: Run Trivy vulnerability scan
        continue-on-error: true
        id: trivy_scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.pull_image.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          timeout: '10m'
          cache-dir: ~/.cache/trivy

      - name: Upload scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy'

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.4.0
        with:
          cosign-release: 'v2.2.3'

      - name: Sign the container image
        id: sign_image
        continue-on-error: true  # Don't fail workflow if signing fails
        run: |
          IMAGE="${{ steps.pull_image.outputs.image }}"
          if ! cosign sign --yes ${IMAGE}; then
            echo "::warning::Image signing failed, but continuing workflow"
            echo "signed=false" >> $GITHUB_OUTPUT
          else
            echo "✅ Image signed: ${IMAGE}"
            echo "signed=true" >> $GITHUB_OUTPUT
          fi

      - name: Print deployment summary
        run: |
          echo "::group::📦 Deployment Information"
          echo "✅ Image: ${{ needs.code-quality.outputs.image_name }}:stable"
          echo "🔖 Digest: ${{ needs.container-build.outputs.image_digest }}"
          if [[ "${{ steps.sign_image.outputs.signed }}" == "true" ]]; then
            echo "🔐 Cosign Signature: ✅"
          else
            echo "⚠️ Cosign Signature: Skipped/Failed"
          fi
          echo "::endgroup::"

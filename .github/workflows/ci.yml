name: Build and Push Non-Production Images

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch: # Allow manual triggering

env:
  CARGO_TERM_COLOR: always # Enable colored Cargo output
  REGISTRY: ghcr.io # Container registry
  BASE_REPO: ${{ github.repository }} # Base repository name

jobs:
  code-quality:
    name: Code Tests & Linting # First job - validate code quality
    runs-on: ubuntu-24.04 # Use latest Ubuntu LTS
    outputs:
      branch_name: ${{ steps.branch_info.outputs.branch_name }} # Export branch name for other jobs
      image_name: ${{ steps.image_name.outputs.image_name }} # Export full image name
      
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4 # Use latest checkout action
        with:
          fetch-depth: 0 # Full history for better versioning

      - name: Extract branch info # Get branch name for image naming
        id: branch_info
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          # Replace slashes with dashes for Docker compatibility
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/\//-/g')
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Detected branch: ${BRANCH_NAME}"
      
      - name: Generate image name with branch # Create full image name with branch
        id: image_name
        run: |
          # Append branch name to base repository name
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.BASE_REPO }}-${{ steps.branch_info.outputs.branch_name }}"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "Full image name: ${IMAGE_NAME}"
      
      - name: Set up Rust toolchain # Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt # Install components in one step
          targets: x86_64-unknown-linux-gnu,aarch64-unknown-linux-gnu # For multi-arch

      - name: Set OpenSSL paths # Configure OpenSSL for native builds
        run: |
          echo "OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include/x86_64-linux-gnu" >> $GITHUB_ENV

      # OPTIMIZATION: Enhanced Rust Caching
      - name: Cache dependencies # Use Swatinem/rust-cache for efficient caching
        uses: Swatinem/rust-cache@v2
        with:
          key: "v1-cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}" # Hash-based cache key
          shared-key: "rust-cache-${{ runner.os }}"
          save-if: true # Always save cache
          cache-targets: true # Cache compiled artifacts
          cache-on-failure: true # Cache even when builds fail
          cache-directories: |
            ~/.cargo/git
            ~/.cargo/registry

      - name: Install seaORM CLI # Install database tools
        uses: taiki-e/install-action@v2 # Faster installation than cargo install
        with:
          tool: sea-orm-cli

      - name: Build # Build all targets for testing
        run: cargo build --all-targets

      - name: Run tests # Run the test suite
        run: cargo test

      - name: Run clippy # Static code analysis
        run: cargo clippy -- -Dwarnings

      - name: Verify formatting # Code style check
        run: cargo fmt --check
        
  container-build:
    name: Build & Push Container # Second job - build and push container images
    runs-on: ubuntu-24.04
    needs: code-quality # Only run if tests pass
    if: ${{ success() }} # Always run when tests succeed
    outputs:
      image_uri: ${{ needs.code-quality.outputs.image_name }}:stable # Pass image URI to next job
      image_digest: ${{ steps.docker_build.outputs.digest }} # Pass image digest to next job
    
    permissions:
      contents: read
      packages: write # Needed for pushing to GHCR
    
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4

      # OPTIMIZATION: BuildKit Optimization Options
      - name: Set up Docker Buildx # Set up enhanced Docker builder
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: --debug
          config-inline: |
            [worker.oci]
              max-parallelism = 4

      - name: Set up QEMU # Set up emulation for multi-arch builds
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Login to GitHub Container Registry # Authenticate with registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata and prepare tags - always using "stable" tag
      - name: Extract Docker metadata # Create tags and labels
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.code-quality.outputs.image_name }}
          tags: |
            type=raw,value=stable
            type=sha,format=long

      # OPTIMIZATION: Multi-level Registry Caching for Docker
      - name: Build and push # Focus only on building and pushing
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          # Use build args for inline cache
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          # Fix the cache export issue with these settings
          cache-from: type=registry,ref=${{ needs.code-quality.outputs.image_name }}:cache
          cache-to: |
            type=registry,ref=${{ needs.code-quality.outputs.image_name }}:cache,mode=max,image-manifest=true,oci-mediatypes=true,ignore-error=true
          # Keep compression settings
          outputs: type=image,compression=zstd,compression-level=3,force-compression=true
          provenance: true
          # Add timeout settings
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # Output image info
      - name: Image build summary # Provide basic build information
        run: |
          echo "‚úÖ Multi-arch container image built and pushed"
          echo "üì¶ Image: ${{ needs.code-quality.outputs.image_name }}:stable"
          echo "üè∑Ô∏è Digest: ${{ steps.docker_build.outputs.digest }}"

  security-scan:
    name: Security Scanning & Signing # Third job - scan and validate the image
    runs-on: ubuntu-24.04
    needs: [code-quality, container-build] # Run after container-build completes
    if: ${{ success() }} # Run only if previous jobs succeeded
    
    permissions:
      contents: read
      packages: read # Only need read for scanning
      id-token: write # Needed for signing
      security-events: write # Needed for security scanning reports
    
    steps:
      - name: Login to GitHub Container Registry # Authenticate with registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for image availability # Give registry time to process the image
        run: |
          echo "Waiting for image to be available in registry..."
          sleep 30
        
      # Pull the image for scanning
      - name: Pull image for scanning # Verify we can pull the image
        run: |
          # Pull the specific image we want to scan
          IMAGE="${{ needs.code-quality.outputs.image_name }}:stable"
          echo "Pulling $IMAGE for security scanning"
          docker pull $IMAGE
          docker images

      # OPTIMIZATION: Trivy Vulnerability Database Caching
      - name: Cache Trivy vulnerability database
        uses: actions/cache@v3
        with:
          path: ~/.cache/trivy
          key: trivy-${{ runner.os }}-${{ github.run_id }}
          restore-keys: |
            trivy-${{ runner.os }}-

      # Security scanning with Trivy
      - name: Run Trivy vulnerability scanner # Scan image for security issues
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.code-quality.outputs.image_name }}:stable
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          timeout: '10m'
          cache-dir: ~/.cache/trivy  # Use cached vulnerability database

      # Upload security scan results to GitHub Security tab
      - name: Upload Trivy scan results # Make results visible in Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'container-security'

      # Image signing with Cosign
      - name: Install cosign # Set up signing tool
        uses: sigstore/cosign-installer@v3.4.0
        with:
          cosign-release: 'v2.2.3'

      - name: Sign the container image # Add cryptographic signature
        run: |
          IMAGE_URI="${{ needs.code-quality.outputs.image_name }}:stable"
          cosign sign --yes ${IMAGE_URI}
          echo "‚úÖ Image signed: ${IMAGE_URI}"

      # Output deployment instructions
      - name: Print deployment information # Generate helpful summary
        run: |
          echo "::group::üìã Deployment Information"
          echo "‚úÖ Image processing completed!"
          echo ""
          echo "üöÄ Image Details:"
          echo "   - Full Image Name: ${{ needs.code-quality.outputs.image_name }}:stable"
          echo "   - Registry: ${{ env.REGISTRY }}"
          echo "   - Repository: ${{ env.BASE_REPO }}-${{ needs.code-quality.outputs.branch_name }}"
          echo "   - Tag: stable"
          echo "   - Supported Architectures: linux/amd64, linux/arm64"
          echo "   - Image Digest: ${{ needs.container-build.outputs.image_digest }}"
          echo ""
          echo "üõ°Ô∏è Security Features:"
          echo "   - Trivy vulnerability scanning completed"
          echo "   - Image signed with Cosign"
          echo ""          
          echo "üì¶ To pull this image:"
          echo "   docker pull ${{ needs.code-quality.outputs.image_name }}:stable"
          echo ""
          echo "üöÄ To deploy with docker-compose:"
          echo "   Update your .env file with:"
          echo "   BACKEND_IMAGE_NAME=${{ needs.code-quality.outputs.image_name }}:stable"
          echo "   Then run: docker-compose up -d"
          echo "::endgroup::"
name: CI and Container Build

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch: # Allow manual triggering

env:
  CARGO_TERM_COLOR: always # Enable colored Cargo output
  REGISTRY: ghcr.io # Container registry
  BASE_REPO: ${{ github.repository }} # Base repository name

jobs:
  test:
    name: Test and Lint # First job - validate code quality
    runs-on: ubuntu-24.04 # Use latest Ubuntu LTS
    permissions:
      contents: read
    outputs:
      branch_name: ${{ steps.branch_info.outputs.branch_name }} # Export branch name for other jobs
      image_name: ${{ steps.image_name.outputs.image_name }} # Export full image name
      
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4 # Use latest checkout action
        with:
          fetch-depth: 0 # Full history for better versioning

      - name: Extract branch info # Get branch name for image naming
        id: branch_info
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          # Replace slashes with dashes for Docker compatibility
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/\//-/g')
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Detected branch: ${BRANCH_NAME}"
      
      - name: Generate image name with branch # Create full image name with branch
        id: image_name
        run: |
          # Append branch name to base repository name
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.BASE_REPO }}-${{ steps.branch_info.outputs.branch_name }}"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "Full image name: ${IMAGE_NAME}"
      
      - name: Set up Rust toolchain # Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt # Install components in one step
          targets: x86_64-unknown-linux-gnu,aarch64-unknown-linux-gnu # For multi-arch

      - name: Set OpenSSL paths # Configure OpenSSL for native builds
        run: |
          echo "OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=/usr/include/x86_64-linux-gnu" >> $GITHUB_ENV

      - name: Cache dependencies # Use Swatinem/rust-cache for efficient caching
        uses: Swatinem/rust-cache@v2
        with:
          key: "v1-cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}" # Hash-based cache key
          shared-key: "rust-cache-${{ runner.os }}"
          save-if: true # Always save cache

      - name: Install seaORM CLI # Install database tools
        uses: taiki-e/install-action@v2 # Faster installation than cargo install
        with:
          tool: sea-orm-cli

      - name: Build # Build all targets for testing
        run: cargo build --all-targets

      - name: Run tests # Run the test suite
        run: cargo test

      - name: Run clippy # Static code analysis
        run: cargo clippy -- -Dwarnings

      - name: Verify formatting # Code style check
        run: cargo fmt --check
        
  build-images:
    name: Build Container Images
    runs-on: ubuntu-24.04
    needs: test # Only run if tests pass
    if: ${{ success() }}
    
    permissions:
      contents: read
      packages: write # Needed for pushing to GHCR
      id-token: write # Needed for signing and attestations
      security-events: write # Needed for security scanning reports
    
    steps:
      - name: Checkout repository # Get source code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx # Set up enhanced Docker builder
        uses: docker/setup-buildx-action@v3

      - name: Set up QEMU # Set up emulation for multi-arch builds
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Login to GitHub Container Registry # Authenticate with registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata and prepare tags - always using "stable" tag
      - name: Extract Docker metadata # Create tags and labels
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.test.outputs.image_name }}
          tags: |
            type=raw,value=stable
            type=sha,format=long

      # Build and push multi-arch image in a single step
      - name: Build and push multi-arch image
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true

      # Wait to ensure image is available for scanning
      - name: Wait for image availability
        run: sleep 10
        
      # Pull the image for scanning
      - name: Pull image to ensure availability 
        run: |
          # Pull the specific image we want to scan
          IMAGE="${{ needs.test.outputs.image_name }}:stable"
          echo "Pulling $IMAGE for security scanning"
          docker pull $IMAGE
          docker images

      # Security scanning with Trivy
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.test.outputs.image_name }}:stable
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          timeout: '10m'

      # Upload security scan results to GitHub Security tab
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'container-security'

      # Image signing with Cosign
      - name: Install cosign
        uses: sigstore/cosign-installer@v3.4.0
        with:
          cosign-release: 'v2.2.3'

      - name: Sign the container image
        run: |
          IMAGE_URI="${{ needs.test.outputs.image_name }}:stable"
          cosign sign --yes ${IMAGE_URI}
          echo "âœ… Image signed: ${IMAGE_URI}"

      # Output deployment instructions
      - name: Print deployment information
        run: |
          echo "::group::ðŸ“‹ Deployment Information"
          echo "âœ… Multi-architecture image build completed!"
          echo ""
          echo "ðŸš€ Image Details:"
          echo "   - Full Image Name: ${{ needs.test.outputs.image_name }}:stable"
          echo "   - Registry: ${{ env.REGISTRY }}"
          echo "   - Repository: ${{ env.BASE_REPO }}-${{ needs.test.outputs.branch_name }}"
          echo "   - Tag: stable"
          echo "   - Supported Architectures: linux/amd64, linux/arm64"
          echo "   - Image Digest: ${{ steps.docker_build.outputs.digest }}"
          echo ""
          echo "ðŸ“¦ To pull this image:"
          echo "   docker pull ${{ needs.test.outputs.image_name }}:stable"
          echo ""
          echo "ðŸš€ To deploy with docker-compose:"
          echo "   Update your .env file with:"
          echo "   BACKEND_IMAGE_NAME=${{ needs.test.outputs.image_name }}:stable"
          echo "   Then run: docker-compose up -d"
          echo "::endgroup::"
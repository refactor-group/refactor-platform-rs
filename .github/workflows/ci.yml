name: Build and Push Non-Production Images

# Restricting permissions globally to the minimum needed
permissions:
  actions: read       # Allows reading workflow actions (e.g., for artifact uploads) - prevents accidental modifications
  contents: read      # Allows reading repository content (e.g., source code) - essential for checkout
  packages: none      # Explicitly denies package access at workflow level - overridden in jobs that need it
  id-token: none      # Explicitly denies ID token requests at workflow level - overridden in jobs that need it
  security-events: none # Explicitly denies security event access at workflow level - overridden in jobs that need it
  pull-requests: none # Explicitly denies pull request access - keeps workflow focused
  issues: none        # Explicitly denies issue access - keeps workflow focused
  statuses: none      # Explicitly denies status access - keeps workflow focused

on:
  pull_request:       # Triggers the workflow on pull requests
    branches:
      - main         # Only triggers for PRs targeting the 'main' branch
    types: [opened, synchronize, reopened] # Triggers on opening, syncing, or reopening a PR
  workflow_dispatch:  # Allows manual triggering of the workflow

env:
  CARGO_TERM_COLOR: always # Enables colored output for Cargo commands
  REGISTRY: ghcr.io        # Specifies the container registry (GitHub Container Registry)
  BASE_REPO: ${{ github.repository }} # Specifies the base repository name (owner/repo)

jobs:
  # Job: Dynamically generates cache keys and image tags per branch/PR
  setup-cache-strategy:
    name: Setup Cache Strategy # Descriptive name for the job
    runs-on: ubuntu-24.04    # Specifies the runner environment (Ubuntu 24.04)
    outputs:                  # Defines outputs that can be used by subsequent jobs
      rust_cache_key: ${{ steps.cache_keys.outputs.rust_cache_key }} # Rust cache key
      rust_restore_keys: ${{ steps.cache_keys.outputs.rust_restore_keys }} # Rust restore keys
      docker_cache_key: ${{ steps.cache_keys.outputs.docker_cache_key }} # Docker cache key
      docker_restore_keys: ${{ steps.cache_keys.outputs.docker_restore_keys }} # Docker restore keys
      branch_name: ${{ steps.branch_info.outputs.branch_name }} # Branch name
      image_name: ${{ steps.branch_info.outputs.image_name }} # Image name
      cache_scope: ${{ steps.cache_keys.outputs.cache_scope }} # Cache scope (branch/PR)

    steps:
      - name: Checkout repository # Checks out the repository to the runner
        uses: actions/checkout@v4 # Uses the official checkout action
        with:
          fetch-depth: 1 # Faster checkout, since only latest commit needed

      - name: Extract branch information # Extracts branch name and creates image name
        id: branch_info # Assigns an ID to the step for referencing its outputs
        run: | # Executes shell commands
          # Get current branch, sanitize it, and create image name
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}} # Gets the branch name from the environment
          BRANCH_NAME_SAFE=${BRANCH_NAME//\//-} # Sanitizes the branch name by replacing slashes with dashes
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.BASE_REPO }}-${BRANCH_NAME_SAFE}" # Creates the image name

          echo "branch_name=$BRANCH_NAME_SAFE" >> $GITHUB_OUTPUT # Sets the branch name as an output
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT # Sets the image name as an output
          echo "original_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT # Sets the original branch name as an output

      - name: Generate cache keys with hierarchical fallback # Generates cache keys for Rust and Docker builds
        id: cache_keys # Assigns an ID to the step for referencing its outputs
        run: | # Executes shell commands
          # Cache Rust and Docker builds based on branch-specific and file-hash logic
          CARGO_HASH="${{ hashFiles('**/Cargo.lock', '**/Cargo.toml') }}" # Generates a hash of Cargo.lock and Cargo.toml
          DOCKER_HASH="${{ hashFiles('Dockerfile', 'docker-compose.yaml', '.dockerignore', '**/Cargo.lock') }}" # Generates a hash of Docker-related files

          if [ "${{ github.event_name }}" == "pull_request" ]; then # Checks if the workflow was triggered by a pull request
            CACHE_SCOPE="pr-${{ github.event.number }}" # Sets the cache scope to the pull request number
          else
            CACHE_SCOPE="branch-${{ steps.branch_info.outputs.branch_name }}" # Sets the cache scope to the branch name
          fi

          RUST_CACHE_KEY="rust-v3-${CACHE_SCOPE}-${CARGO_HASH}" # Creates the Rust cache key
          RUST_RESTORE_KEYS="rust-v3-${CACHE_SCOPE}-|rust-v3-branch-main-|rust-v3-" # Creates the Rust restore keys
          # Hierarchical fallback: 1) branch/PR-specific, 2) main branch, 3) no scope

          DOCKER_CACHE_KEY="docker-v3-${CACHE_SCOPE}-${DOCKER_HASH}" # Creates the Docker cache key
          DOCKER_RESTORE_KEYS="docker-v3-${CACHE_SCOPE}-|docker-v3-branch-main-|docker-v3-" # Creates the Docker restore keys
          # Hierarchical fallback: 1) branch/PR-specific, 2) main branch, 3) no scope

          echo "rust_cache_key=$RUST_CACHE_KEY" >> $GITHUB_OUTPUT # Sets the Rust cache key as an output
          echo "rust_restore_keys=$RUST_RESTORE_KEYS" >> $GITHUB_OUTPUT # Sets the Rust restore keys as an output
          echo "docker_cache_key=$DOCKER_CACHE_KEY" >> $GITHUB_OUTPUT # Sets the Docker cache key as an output
          echo "docker_restore_keys=$DOCKER_RESTORE_KEYS" >> $GITHUB_OUTPUT # Sets the Docker restore keys as an output
          echo "cache_scope=$CACHE_SCOPE" >> $GITHUB_OUTPUT # Sets the cache scope as an output

  # Job: Run Rust tests with optimized cache usage
  rust-tests:
    name: Rust Tests # Descriptive name for the job
    runs-on: ubuntu-24.04 # Specifies the runner environment (Ubuntu 24.04)
    needs: setup-cache-strategy # Specifies that this job depends on the 'setup-cache-strategy' job

    steps:
      - name: Checkout repository # Checks out the repository to the runner
        uses: actions/checkout@v4 # Uses the official checkout action
        with:
          fetch-depth: 1 # Faster checkout, since only latest commit needed

      - name: Install Rust toolchain # Installs the Rust toolchain
        uses: dtolnay/rust-toolchain@stable # Uses the official Rust toolchain action
        with:
          components: rustfmt # Installs the 'rustfmt' component
          targets: x86_64-unknown-linux-gnu # Installs the target 'x86_64-unknown-linux-gnu'

      - name: Cache Rust dependencies (with timeout protection) # Caches Rust dependencies
        uses: actions/cache@v4 # Uses the official cache action
        with:
          path: | # Specifies the paths to cache
            ~/.cargo/bin/ # Cargo binaries
            ~/.cargo/registry/index/ # Cargo registry index
            ~/.cargo/registry/cache/ # Cargo registry cache
            ~/.cargo/git/db/ # Cargo git database
            target/ # Target directory
          key: ${{ needs.setup-cache-strategy.outputs.rust_cache_key }} # Specifies the cache key
          restore-keys: ${{ needs.setup-cache-strategy.outputs.rust_restore_keys }} # Specifies the restore keys
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 5 # Prevent long waits on cache access

      - name: Install seaORM CLI with caching # Installs the seaORM CLI
        uses: taiki-e/install-action@v2 # Uses the 'install-action' action
        with:
          tool: sea-orm-cli # Installs the 'sea-orm-cli' tool

      - name: Run tests with optimized settings # Runs Rust tests
        run: | # Executes shell commands
          rm -rf target/debug/incremental 2>/dev/null || true # Clears the incremental compilation cache
          cargo test --release --all-targets # Runs tests in release mode for speed
        env:
          CARGO_INCREMENTAL: 0 # Disables incremental compilation
          RUSTFLAGS: "-C debuginfo=0 -C opt-level=2" # Optimizes the build for speed
          CARGO_NET_RETRY: 3 # Sets the number of retries for network operations
          CARGO_NET_GIT_FETCH_WITH_CLI: true # Forces git fetch to use the CLI

      - name: Check code formatting # Checks code formatting
        run: cargo fmt --check # Runs 'cargo fmt' in check mode

      - name: Cache cleanup (prevent cache bloat) # Cleans up the cache
        run: | # Executes shell commands
          find target -name "*.pdb" -delete 2>/dev/null || true # Deletes PDB files
          find target -name "*.dSYM" -type d -exec rm -rf {} + 2>/dev/null || true # Deletes dSYM directories
          find target -type f -name "*.rmeta" -delete 2>/dev/null || true # Deletes rmeta files
          find target -type f -name "*.rlib" -mtime +7 -delete 2>/dev/null || true # Deletes rlib files older than 7 days

  # Job: Rust lint with Clippy
  rust-lint:
    name: Rust Lint # Descriptive name for the job
    runs-on: ubuntu-24.04 # Specifies the runner environment (Ubuntu 24.04)
    needs: setup-cache-strategy # Specifies that this job depends on the 'setup-cache-strategy' job

    steps:
      - name: Checkout repository # Checks out the repository to the runner
        uses: actions/checkout@v4 # Uses the official checkout action

      - name: Install Rust toolchain # Installs the Rust toolchain
        uses: dtolnay/rust-toolchain@stable # Uses the official Rust toolchain action
        with:
          components: clippy # Installs the 'clippy' component
          targets: x86_64-unknown-linux-gnu # Installs the target 'x86_64-unknown-linux-gnu'

      - name: Cache Rust dependencies (lint-specific) # Caches Rust dependencies
        uses: actions/cache@v4 # Uses the official cache action
        with:
          path: | # Specifies the paths to cache
            ~/.cargo/bin/ # Cargo binaries
            ~/.cargo/registry/index/ # Cargo registry index
            ~/.cargo/registry/cache/ # Cargo registry cache
            ~/.cargo/git/db/ # Cargo git database
            target/ # Target directory
          key: lint-${{ needs.setup-cache-strategy.outputs.rust_cache_key }} # Specifies the cache key
          restore-keys: | # Specifies the restore keys
            lint-${{ needs.setup-cache-strategy.outputs.rust_restore_keys }} # Restore key with lint prefix
            ${{ needs.setup-cache-strategy.outputs.rust_restore_keys }} # Restore key without lint prefix
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 5 # Prevent long waits on cache access

      - name: Lint with clippy # Runs Clippy
        run: | # Executes shell commands
          rm -rf target/debug/incremental 2>/dev/null || true # Clears the incremental compilation cache
          cargo clippy --all-targets --all-features -- -D warnings # Runs Clippy with all targets and features
        env:
          CARGO_INCREMENTAL: 0 # Disables incremental compilation
          RUSTFLAGS: "-C debuginfo=0" # Disables debug information
          CARGO_NET_RETRY: 3 # Sets the number of retries for network operations

  # Job: Build and push container image to GHCR with caching
  container-build:
    name: Build & Push Container # Descriptive name for the job
    runs-on: ubuntu-24.04 # Specifies the runner environment (Ubuntu 24.04)
    needs: [setup-cache-strategy, rust-tests, rust-lint] # Specifies that this job depends on the 'setup-cache-strategy', 'rust-tests', and 'rust-lint' jobs
    if: ${{ success() }} # Only run if all prior jobs passed
    outputs: # Defines outputs that can be used by subsequent jobs
      image_uri: ${{ needs.setup-cache-strategy.outputs.image_name }}:stable # Image URI
      image_digest: ${{ steps.build.outputs.digest }} # Image digest

    permissions: # Specifies the permissions for this job
      contents: read # Allows reading repository content (e.g., Dockerfile)
      packages: write # Allows writing to the GitHub Container Registry
      id-token: write # Allows requesting a JWT

    steps:
      - name: Checkout repository # Checks out the repository to the runner
        uses: actions/checkout@v4 # Uses the official checkout action

      - name: Set up Docker Buildx with optimized settings # Sets up Docker Buildx
        uses: docker/setup-buildx-action@v3 # Uses the official Docker Buildx action
        with:
          driver-opts: | # Specifies driver options
            image=moby/buildkit:v0.12.5 # Uses BuildKit v0.12.5
            network=host # Uses host network
          buildkitd-flags: | # Specifies BuildKit daemon flags
            --allow-insecure-entitlement security.insecure # Allows insecure entitlements
            --allow-insecure-entitlement network.host # Allows host network

      - name: Set up QEMU # Sets up QEMU
        uses: docker/setup-qemu-action@v3 # Uses the official QEMU action
        with:
          platforms: linux/amd64,linux/arm64 # Specifies the platforms to emulate

      - name: Login to GitHub Container Registry # Logs in to the GitHub Container Registry
        uses: docker/login-action@v3 # Uses the official Docker login action
        with:
          registry: ${{ env.REGISTRY }} # Specifies the registry
          username: ${{ github.actor }} # Specifies the username
          password: ${{ secrets.GITHUB_TOKEN }} # Specifies the password

      - name: Setup Docker layer caching (robust) # Sets up Docker layer caching
        run: | # Executes shell commands
          mkdir -p /tmp/.buildx-cache-new # Creates the cache directory
          chmod 755 /tmp/.buildx-cache-new # Sets the permissions for the cache directory

      - name: Cache Docker layers (primary strategy) # Caches Docker layers
        uses: actions/cache@v4 # Uses the official cache action
        with:
          path: /tmp/.buildx-cache # Specifies the path to cache
          key: ${{ needs.setup-cache-strategy.outputs.docker_cache_key }} # Specifies the cache key
          restore-keys: ${{ needs.setup-cache-strategy.outputs.docker_restore_keys }} # Specifies the restore keys
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 10 # Prevent long waits on cache access

      - name: Generate Docker metadata # Generates Docker metadata
        id: meta # Assigns an ID to the step for referencing its outputs
        uses: docker/metadata-action@v5 # Uses the official Docker metadata action
        with:
          images: ${{ needs.setup-cache-strategy.outputs.image_name }} # Specifies the image name
          tags: | # Specifies the tags
            type=raw,value=stable # Adds the 'stable' tag
            type=raw,value=latest # Adds the 'latest' tag
            type=sha,format=short # Adds the short SHA tag
          annotations: | # Specifies the annotations
            org.opencontainers.image.description=Refactor Platform - Branch: ${{ needs.setup-cache-strategy.outputs.branch_name }} # Adds the image description

      - name: Build and push with robust caching # Builds and pushes the container image
        id: build # Assigns an ID to the step for referencing its outputs
        uses: docker/build-push-action@v5 # Uses the official Docker build and push action
        timeout-minutes: 10 # Sets the timeout for the build and push operation
        with:
          context: . # Specifies the build context
          platforms: linux/amd64,linux/arm64 # Specifies the platforms to build for
          push: true # Enables pushing the image to the registry
          tags: ${{ steps.meta.outputs.tags }} # Specifies the tags
          build-args: | # Specifies build arguments
            BUILDKIT_INLINE_CACHE=1 # Enables BuildKit inline cache
            CARGO_INCREMENTAL=0 # Disables incremental compilation
            RUSTFLAGS=-C target-cpu=generic # Sets the target CPU
          cache-from: | # Specifies the cache sources
            type=local,src=/tmp/.buildx-cache # Uses the local cache
            type=gha,scope=${{ needs.setup-cache-strategy.outputs.cache_scope }} # Uses the GitHub Actions cache with branch/PR scope
            type=gha,scope=main # Uses the GitHub Actions cache with main branch scope
          cache-to: | # Specifies the cache destinations
            type=local,dest=/tmp/.buildx-cache-new,mode=max # Exports to the local cache
            type=gha,mode=max,scope=${{ needs.setup-cache-strategy.outputs.cache_scope }} # Exports to the GitHub Actions cache with branch/PR scope
          outputs: type=image,compression=zstd,compression-level=3,force-compression=true # Specifies the output settings
          provenance: false # Disables provenance attestation
          sbom: true # Enables Software Bill of Materials (SBOM) generation
        env:
          BUILDKIT_PROGRESS: plain # Sets the BuildKit progress output to plain
          DOCKER_BUILDKIT: 1 # Enables Docker BuildKit

      - name: Rotate cache (prevent corruption) # Rotates the cache
        run: | # Executes shell commands
          rm -rf /tmp/.buildx-cache || true # Deletes the old cache directory
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true # Moves the new cache directory to the old cache directory

      - name: Registry cache export (separate step, non-blocking) # Exports the cache to the registry
        continue-on-error: true # Allows the workflow to continue even if this step fails
        run: | # Executes shell commands
          timeout 300 docker buildx build \ # Sets the timeout to 300 seconds
            --cache-from=type=local,src=/tmp/.buildx-cache \ # Uses the local cache
            --cache-to=type=registry,ref=${{ needs.setup-cache-strategy.outputs.image_name }}:cache,mode=max \ # Exports to the registry cache
            --platform linux/amd64 \ # Specifies the platform
            --output=type=cacheonly \ # Specifies the output type
            . || echo "Registry cache export failed (non-critical)" # Runs the Docker buildx command

      - name: Verify build success # Verifies that the build was successful
        run: | # Executes shell commands
          echo "✅ Build completed successfully" # Prints a success message
          echo "📦 Image: ${{ needs.setup-cache-strategy.outputs.image_name }}:stable" # Prints the image name
          echo "🔖 Digest: ${{ steps.build.outputs.digest }}" # Prints the image digest
          echo "💾 Cache Scope: ${{ needs.setup-cache-strategy.outputs.cache_scope }}" # Prints the cache scope

  # Job: Run Trivy for vulnerability scan
  security-scan:
    name: Security Scan # Descriptive name for the job
    runs-on: ubuntu-24.04 # Specifies the runner environment (Ubuntu 24.04)
    needs: [setup-cache-strategy, container-build] # Specifies that this job depends on the 'setup-cache-strategy' and 'container-build' jobs
    if: ${{ success() }} # Only run if all prior jobs passed

    permissions: # Specifies the permissions for this job
      contents: read # Allows reading repository content
      packages: write # Allows writing to the GitHub Container Registry
      security-events: write # Required to upload SARIF to GitHub Security tab

    steps:
      - name: Checkout repository # Checks out the repository to the runner
        uses: actions/checkout@v4 # Uses the official checkout action

      - name: Login to GitHub Container Registry # Logs in to the GitHub Container Registry
        uses: docker/login-action@v3 # Uses the official Docker login action
        with:
          registry: ${{ env.REGISTRY }} # Specifies the registry
          username: ${{ github.actor }} # Specifies the username
          password: ${{ secrets.GITHUB_TOKEN }} # Specifies the password

      - name: Cache Trivy database # Caches the Trivy database
        uses: actions/cache@v4 # Uses the official cache action
        with:
          path: ~/.cache/trivy # Specifies the path to cache
          key: trivy-db-${{ github.run_number }} # Specifies the cache key
          restore-keys: | # Specifies the restore keys
            trivy-db- # Restore key without run number
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 3 # Prevent long waits on cache access

      - name: Run Trivy vulnerability scanner # Runs the Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master # Uses the official Trivy action
        with:
          image-ref: ${{ needs.setup-cache-strategy.outputs.image_name }}:stable # Specifies the image to scan
          format: 'sarif' # Specifies the output format
          output: 'trivy-results.sarif' # Specifies the output file
          severity: 'CRITICAL,HIGH' # Specifies the severity level
          timeout: '10m' # Sets the timeout to 10 minutes
          cache-dir: ~/.cache/trivy # Specifies the cache directory
          scanners: 'vuln' # Specifies the scanners to use

      - name: Upload Trivy scan results # Uploads the Trivy scan results
        uses: github/codeql-action/upload-sarif@v3 # Uses the official CodeQL action
        if: always() # Always run this step
        with:
          sarif_file: 'trivy-results.sarif' # Specifies the SARIF file
          category: 'trivy' # Specifies the category

  # Job: Provide cleanup visibility
  cache-maintenance:
    name: Cache Maintenance # Descriptive name for the job
    runs-on: ubuntu-24.04 # Specifies the runner environment (Ubuntu 24.04)
    needs: [setup-cache-strategy, container-build] # Specifies that this job depends on the 'setup-cache-strategy' and 'container-build' jobs
    if: always() # Always run this job

    steps:
      - name: Cache health report # Generates a cache health report
        run: | # Executes shell commands
          echo "🔍 Cache Health Report" # Prints the report header
          echo "Cache Scope: ${{ needs.setup-cache-strategy.outputs.cache_scope }}" # Prints the cache scope
          echo "Build Status: ${{ needs.container-build.result }}" # Prints the build status
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" # Prints the timestamp

      - name: Cleanup old caches (if main branch) # Cleans up old caches
        if: github.ref == 'refs/heads/main' # Only run this step on the main branch
        run: | # Executes shell commands
          echo "🧹 Cache cleanup would run here for main branch" # Prints a message
          echo "This step can be enhanced with GitHub CLI to clean old caches" # Prints a message

  # Job: Summarize deployment outcomes and metadata
  deployment-summary:
    name: Deployment Summary # Descriptive name for the job
    runs-on: ubuntu-24.04 # Specifies the runner environment (Ubuntu 24.04)
    needs: [setup-cache-strategy, container-build, security-scan] # Specifies that this job depends on the 'setup-cache-strategy', 'container-build', and 'security-scan' jobs
    if: always() # Always run this job

    steps:
      - name: Generate deployment summary # Generates a deployment summary
        run: | # Executes shell commands
          mkdir -p ./artifacts # Creates the artifacts directory
          { # Creates a block of commands
            echo "# 🚀 Deployment Summary" # Prints the summary header
            echo "" # Prints a blank line
            echo "| Metric | Value |" # Prints the table header
            echo "|--------|-------|" # Prints the table separator
            echo "| **Branch** | ${{ needs.setup-cache-strategy.outputs.branch_name }} |" # Prints the branch name
            echo "| **Image** | ${{ needs.setup-cache-strategy.outputs.image_name }}:stable |" # Prints the image name
            echo "| **Cache Scope** | ${{ needs.setup-cache-strategy.outputs.cache_scope }} |" # Prints the cache scope
            echo "| **Build Status** | ${{ needs.container-build.result }} |" # Prints the build status
            echo "| **Security Scan** | ${{ needs.security-scan.result }} |" # Prints the security scan result
            echo "| **Commit** | ${{ github.sha }} |" # Prints the commit SHA
            echo "| **Timestamp** | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |" # Prints the timestamp
            echo "" # Prints a blank line
            echo "## 💾 Cache Strategy" # Prints the cache strategy header
            echo "- **Scope**: Branch/PR specific caching" # Prints the cache scope
            echo "- **Fallback**: Hierarchical cache restoration" # Prints the cache fallback
            echo "- **Protection**: EOF error prevention measures" # Prints the EOF error prevention
          } > ./artifacts/deployment-summary.md # Writes the summary to a file

      - name: Upload deployment summary # Uploads the deployment summary
        uses: actions/upload-artifact@v4 # Uses the official upload artifact action
        with:
          name: deployment-summary-${{ needs.setup-cache-strategy.outputs.cache_scope }} # Specifies the artifact name
          path: ./artifacts/deployment-summary.md # Specifies the path to the artifact
          retention-days: 30

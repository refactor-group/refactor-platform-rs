# =============================================================================
# PR Preview Deployment Workflow
# =============================================================================
# Purpose: Deploys isolated PR preview environments to RPi5 via Tailscale
# Features: ARM64 native builds, multi-tier caching, secure VPN deployment
# Target: Raspberry Pi 5 (ARM64) with Docker Compose via Tailscale SSH
# =============================================================================

name: Deploy PR Preview to RPi5

# =============================================================================
# Workflow Triggers - When this workflow runs
# =============================================================================
on:
  # Automatically trigger on PR events to main branch
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

  # Manual trigger for testing and debugging deployments
  workflow_dispatch:
    inputs:
      backend_branch:
        description: "Backend branch to deploy"
        required: true
        default: "main"
        type: string
      pr_number:
        description: "PR number (auto-detected for PR triggers)"
        required: false
        type: string
      force_rebuild:
        description: "Force rebuild without cache"
        required: false
        default: false
        type: boolean

# =============================================================================
# Concurrency Control - Prevent conflicting deployments
# =============================================================================
concurrency:
  # Only one deployment per PR to prevent port conflicts and resource issues
  group: preview-deploy-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

# =============================================================================
# GitHub Permissions - Minimal required permissions for security
# =============================================================================
permissions:
  contents: read
  packages: write
  pull-requests: write
  attestations: write
  id-token: write

# =============================================================================
# Global Environment Variables - Shared across all jobs
# =============================================================================
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: short

jobs:
  # ===========================================================================
  # JOB 1: CI Dependency Gate - Wait for Essential Checks Only
  # ===========================================================================
  # Purpose: Wait for lint and test jobs to pass before expensive ARM64 builds
  # Why: Prevents wasting ARM64 runner time on code that fails basic checks
  # Note: Only waits for lint/test, NOT the docker build - allows parallel execution
  # ===========================================================================
  wait-for-ci:
    name: Wait for Essential CI Checks
    # Use standard x86_64 runner for lightweight CI checking
    runs-on: ubuntu-24.04
    if: github.event_name == 'pull_request'

    steps:
      # Wait for lint job from build-test-push.yml workflow to complete
      # This ensures code quality before proceeding to ARM64 builds
      - name: Wait for Lint Check
        uses: fountainhead/action-wait-for-check@v1.2.0
        id: wait-for-lint
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          checkName: "Lint & Format" # Must match job name in build-test-push.yml
          ref: ${{ github.event.pull_request.head.sha || github.sha }} # Check specific commit
          timeoutSeconds: 300 # 5 minute timeout (lint is fast)
          intervalSeconds: 10 # Check every 10 seconds

      # Wait for test job to ensure functionality before deployment
      # Prevents deploying broken code to preview environment
      - name: Wait for Test Check
        uses: fountainhead/action-wait-for-check@v1.2.0
        id: wait-for-test
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          checkName: "Build & Test" # Must match job name in build-test-push.yml
          ref: ${{ github.event.pull_request.head.sha || github.sha }} # Check specific commit
          timeoutSeconds: 600 # 10 minute timeout (tests take longer)
          intervalSeconds: 10 # Check every 10 seconds

      # Fail fast if essential CI checks didn't pass
      # This saves expensive ARM64 runner minutes and provides quick feedback
      # Note: We don't wait for docker build - that can run in parallel
      - name: Check Essential CI Status
        if: steps.wait-for-lint.outputs.conclusion != 'success' || steps.wait-for-test.outputs.conclusion != 'success'
        run: |
          echo "::error::Essential CI checks failed. Lint: ${{ steps.wait-for-lint.outputs.conclusion }}, Test: ${{ steps.wait-for-test.outputs.conclusion }}"
          echo "::notice::Docker build from main workflow can run in parallel - we only need lint and test to pass"
          exit 1

      # Log successful dependency resolution for debugging
      - name: CI Dependencies Satisfied
        run: |
          echo "::notice::✅ Essential CI checks passed - proceeding with ARM64 preview build"
          echo "::notice::📝 Lint status: ${{ steps.wait-for-lint.outputs.conclusion }}"
          echo "::notice::🧪 Test status: ${{ steps.wait-for-test.outputs.conclusion }}"
          echo "::notice::🚀 ARM64 preview build can now proceed in parallel with main workflow's x86_64 docker build"

  # ===========================================================================
  # JOB 2: ARM64 Image Build with Aggressive Caching
  # ===========================================================================
  # Purpose: Build ARM64 Docker image optimized for RPi5 deployment
  # Why: Native ARM64 builds are 5-10x faster than emulation
  # Optimization: Runs in parallel with main workflow's docker build job
  # Caching: Multi-tier strategy (PR → branch → main → shared) for speed
  # ===========================================================================
  build-arm64-image:
    name: Build ARM64 Backend Image
    # Use correct ARM64 runner label for GitHub (if available on your plan)
    # For public repos, ARM64 runners require GitHub Team/Enterprise
    # Alternative: Use ubuntu-24.04 with QEMU emulation as fallback
    runs-on: ${{ github.repository_owner == 'refactor-group' && 'ubuntu-24.04-arm' || 'ubuntu-24.04' }}
    environment: pr-preview
    # Run after essential CI passes (for PRs) or immediately (for manual dispatch)
    # Modified: Only depends on lint/test, not docker build - enables parallel execution
    needs: [wait-for-ci]
    if: always() && (github.event_name == 'workflow_dispatch' || needs.wait-for-ci.result == 'success')

    # Export values to subsequent jobs for deployment coordination
    outputs:
      pr_number: ${{ steps.context.outputs.pr_number }}
      image_tag_pr: ${{ steps.context.outputs.image_tag_pr }}
      image_tag_sha: ${{ steps.context.outputs.image_tag_sha }}
      backend_branch: ${{ steps.context.outputs.backend_branch }}
      is_native_arm64: ${{ steps.context.outputs.is_native_arm64 }}

    steps:
      # Calculate PR context and generate consistent image tags
      # Handles both PR events and manual dispatch with different logic
      - name: Set Deployment Context
        id: context
        run: |
          # Determine if we're running on native ARM64 or emulation
          if [[ "$(uname -m)" == "aarch64" ]]; then
            echo "is_native_arm64=true" >> $GITHUB_OUTPUT
            echo "::notice::🚀 Running on native ARM64 runner"
          else
            echo "is_native_arm64=false" >> $GITHUB_OUTPUT
            echo "::warning::⚠️ Running on x86_64 with ARM64 emulation (slower builds)"
          fi

          # Determine PR number and branch based on trigger type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUM="${{ github.event.pull_request.number }}"
            BACKEND_BRANCH="${{ github.head_ref }}"
          else
            PR_NUM="${{ inputs.pr_number }}"
            # Generate pseudo-PR number for manual runs (9000+ avoids conflicts)
            if [[ -z "$PR_NUM" ]]; then
              PR_NUM=$((9000 + ${{ github.run_number }}))
            fi
            BACKEND_BRANCH="${{ inputs.backend_branch }}"
          fi

          # Export context for subsequent steps
          echo "pr_number=${PR_NUM}" >> $GITHUB_OUTPUT
          echo "backend_branch=${BACKEND_BRANCH}" >> $GITHUB_OUTPUT

          # Generate Docker image tags for deployment and traceability
          IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          IMAGE_TAG_PR="${IMAGE_BASE}:pr-${PR_NUM}"                      # Latest for PR
          IMAGE_TAG_SHA="${IMAGE_BASE}:pr-${PR_NUM}-${{ github.sha }}"   # Specific commit
          echo "image_tag_pr=${IMAGE_TAG_PR}" >> $GITHUB_OUTPUT
          echo "image_tag_sha=${IMAGE_TAG_SHA}" >> $GITHUB_OUTPUT

          # Log deployment context for debugging
          echo "::notice::🚀 Building ARM64 PR #${PR_NUM} from branch '${BACKEND_BRANCH}'"
          echo "::notice::📦 Image: ${IMAGE_TAG_PR}"
          echo "::notice::⚡ Building in parallel with main workflow's x86_64 docker build"

      # Checkout the specific branch being deployed (not always main)
      # Critical for feature branch deployments and manual dispatch
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.context.outputs.backend_branch }}

      # Setup QEMU for ARM64 emulation if running on x86_64
      # Only needed when ARM64 native runners are not available
      - name: Set up QEMU for ARM64 emulation
        if: steps.context.outputs.is_native_arm64 != 'true'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/arm64
          image: tonistiigi/binfmt:latest

      # Install Rust toolchain with ARM64 target for native or cross compilation
      # Target depends on whether we're on native ARM64 or x86_64 with emulation
      - name: Install Rust Toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ steps.context.outputs.is_native_arm64 == 'true' && 'aarch64-unknown-linux-gnu' || 'aarch64-unknown-linux-gnu' }}

      # Setup hierarchical Rust dependency caching for maximum reuse
      # Cache strategy: PR-specific → branch-specific → shared ARM64
      - name: Setup Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "arm64-preview" # Global cache namespace
          key: ${{ steps.context.outputs.backend_branch }}-${{ steps.context.outputs.pr_number }} # Specific cache key
          cache-all-crates: true # Cache all crate dependencies
          save-if: ${{ github.ref == 'refs/heads/main' || github.event_name == 'pull_request' }} # Save cache conditions

      # Setup sccache for Rust compilation caching across builds
      # Works in conjunction with Rust cache for maximum compilation speed
      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.6
        with:
          version: "latest"

      # Configure sccache as Rust compiler wrapper for cached compilation
      # This can reduce Rust compilation time by 80%+ for repeated builds
      - name: Configure sccache Environment
        run: |
          echo "RUSTC_WRAPPER=sccache" >> $GITHUB_ENV     # Tell rustc to use sccache
          echo "SCCACHE_GHA_ENABLED=true" >> $GITHUB_ENV  # Enable GitHub Actions integration

          # Display initial cache statistics for debugging
          echo "::group::sccache initial stats"
          sccache --show-stats
          echo "::endgroup::"

      # Authenticate with GitHub Container Registry for image push/pull
      # Uses built-in GITHUB_TOKEN for seamless authentication
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Setup Docker Buildx with optimizations for ARM64 builds
      # Uses latest BuildKit for best performance and feature support
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      # Check if image already exists to enable intelligent build skipping
      # Saves significant time by avoiding redundant builds for same commit
      - name: Check for Existing Image
        id: check_image
        run: |
          # Check if SHA-specific image already exists in registry
          if docker manifest inspect ${{ steps.context.outputs.image_tag_sha }} >/dev/null 2>&1; then
            echo "image_exists=true" >> $GITHUB_OUTPUT
            echo "::notice::📦 Image already exists for SHA ${{ github.sha }}"
          else
            echo "image_exists=false" >> $GITHUB_OUTPUT
            echo "::notice::🔨 Building new ARM64 image for SHA ${{ github.sha }}"
          fi

      # Build and push ARM64 image with sophisticated multi-tier caching
      # Only runs if image doesn't exist or force rebuild is requested
      - name: Build and Push ARM64 Backend Image
        id: build_push
        if: steps.check_image.outputs.image_exists != 'true' || inputs.force_rebuild == true
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/arm64 # Target RPi5 architecture
          push: true
          tags: |
            ${{ steps.context.outputs.image_tag_pr }}
            ${{ steps.context.outputs.image_tag_sha }}

          # Multi-tier cache strategy for maximum build speed
          # Priority: PR cache → branch cache → main cache → shared ARM64 cache
          cache-from: |
            ${{ inputs.force_rebuild != true && format('type=gha,scope=pr-{0}', steps.context.outputs.pr_number) || '' }}
            ${{ inputs.force_rebuild != true && format('type=gha,scope=branch-{0}', steps.context.outputs.backend_branch) || '' }}
            ${{ inputs.force_rebuild != true && 'type=gha,scope=main' || '' }}
            ${{ inputs.force_rebuild != true && 'type=gha,scope=arm64-shared' || '' }}

          # Write cache back to PR-specific and shared scopes
          cache-to: |
            ${{ inputs.force_rebuild != true && format('type=gha,mode=max,scope=pr-{0}', steps.context.outputs.pr_number) || '' }}
            ${{ inputs.force_rebuild != true && 'type=gha,mode=max,scope=arm64-shared' || '' }}

          # Comprehensive OCI labels for image metadata and traceability
          labels: |
            org.opencontainers.image.title=Refactor Platform Backend PR-${{ steps.context.outputs.pr_number }}
            org.opencontainers.image.description=PR preview for branch ${{ steps.context.outputs.backend_branch }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            pr.number=${{ steps.context.outputs.pr_number }}
            pr.branch=${{ steps.context.outputs.backend_branch }}

          # Build arguments for optimized Docker build performance
          build-args: |
            BUILDKIT_INLINE_CACHE=1     # Enable BuildKit inline caching
            CARGO_INCREMENTAL=0         # Disable incremental for sccache compatibility
            RUSTC_WRAPPER=sccache       # Use sccache inside Docker build

          provenance: true # Generate build provenance for security
          sbom: false # Disable SBOM for faster builds (enable for production)

      # Re-tag existing image if we skipped the build step
      # Ensures PR tag always points to correct image for deployment
      - name: Tag Existing Image
        if: steps.check_image.outputs.image_exists == 'true' && inputs.force_rebuild != true
        run: |
          # Create PR tag pointing to existing SHA-specific image
          docker buildx imagetools create \
            --tag ${{ steps.context.outputs.image_tag_pr }} \
            ${{ steps.context.outputs.image_tag_sha }}

      # Display final sccache statistics for build optimization insights
      # Helps developers understand cache hit ratios and optimization effectiveness
      - name: Display sccache Statistics
        if: always()
        run: |
          echo "::group::sccache final stats"
          sccache --show-stats
          echo "::endgroup::"

      # Generate cryptographic attestation of how the image was built
      # Provides supply chain security and build provenance verification
      - name: Attest Build Provenance
        if: steps.build_push.conclusion == 'success'
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ steps.context.outputs.image_tag_pr }}
          subject-digest: ${{ steps.build_push.outputs.digest }}
          push-to-registry: true

  # ===========================================================================
  # JOB 3: RPi5 Deployment via Tailscale
  # ===========================================================================
  # Purpose: Deploy Docker Compose stack to RPi5 using Tailscale VPN
  # Why: Secure deployment without exposing RPi5 to public internet
  # Features: Dynamic port allocation, service orchestration, health monitoring
  # ===========================================================================
  deploy-to-rpi5:
    name: Deploy to RPi5 via Tailscale
    # Use same ARM64 logic as build job for consistency
    runs-on: ${{ github.repository_owner == 'refactor-group' && 'ubuntu-24.04-arm' || 'ubuntu-24.04' }}
    needs: build-arm64-image
    environment: pr-preview

    steps:
      # Calculate unique port assignments to avoid conflicts between PRs
      # Each PR gets its own set of ports based on PR number offset
      - name: Calculate Deployment Ports
        id: ports
        run: |
          PR_NUM="${{ needs.build-arm64-image.outputs.pr_number }}"

          # Dynamic port allocation formula: base_port + pr_number
          BACKEND_CONTAINER_PORT=${{ vars.BACKEND_PORT_BASE || '4000' }}                    # Internal container port
          BACKEND_EXTERNAL_PORT=$((${{ vars.BACKEND_PORT_BASE || '4000' }} + PR_NUM))      # External RPi5 port
          POSTGRES_EXTERNAL_PORT=$((${{ vars.POSTGRES_PORT_BASE || '5432' }} + PR_NUM))    # PostgreSQL port
          FRONTEND_EXTERNAL_PORT=$((${{ vars.FRONTEND_PORT_BASE || '3000' }} + PR_NUM))    # Frontend port

          # Export port assignments for deployment configuration
          echo "backend_container_port=${BACKEND_CONTAINER_PORT}" >> $GITHUB_OUTPUT
          echo "backend_port=${BACKEND_EXTERNAL_PORT}" >> $GITHUB_OUTPUT
          echo "postgres_port=${POSTGRES_EXTERNAL_PORT}" >> $GITHUB_OUTPUT
          echo "frontend_port=${FRONTEND_EXTERNAL_PORT}" >> $GITHUB_OUTPUT
          echo "project_name=pr-${PR_NUM}" >> $GITHUB_OUTPUT

          # Log port allocation for debugging and monitoring
          echo "::notice::🔌 Postgres: ${POSTGRES_EXTERNAL_PORT} | Backend: ${BACKEND_EXTERNAL_PORT} | Frontend: ${FRONTEND_EXTERNAL_PORT}"

      # Checkout repository to access docker-compose configuration files
      # Uses same branch as the image build for consistency
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.build-arm64-image.outputs.backend_branch }}

      # Connect to Tailscale VPN for secure RPi5 access
      # Uses OAuth for ephemeral, keyless authentication (no SSH key management)
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID_PR_PREVIEW }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET_PR_PREVIEW }}
          tags: tag:github-actions # Tag for identification in Tailscale admin
          version: latest
          use-cache: true

      # Execute deployment to RPi5 via Tailscale SSH tunnel
      # Transfers compose file and orchestrates multi-service deployment
      - name: Deploy to Neo via Tailscale SSH
        env:
          # Deployment context variables from previous jobs
          PR_NUMBER: ${{ needs.build-arm64-image.outputs.pr_number }}
          BACKEND_IMAGE: ${{ needs.build-arm64-image.outputs.image_tag_pr }}
          PROJECT_NAME: ${{ steps.ports.outputs.project_name }}

          # Port assignments for service binding
          PR_POSTGRES_PORT: ${{ steps.ports.outputs.postgres_port }}
          PR_BACKEND_PORT: ${{ steps.ports.outputs.backend_port }}
          PR_BACKEND_CONTAINER_PORT: ${{ steps.ports.outputs.backend_container_port }}
          PR_FRONTEND_PORT: ${{ steps.ports.outputs.frontend_port }}

          # Database configuration from secrets
          POSTGRES_USER: ${{ secrets.PR_PREVIEW_POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD: ${{ secrets.PR_PREVIEW_POSTGRES_PASSWORD || 'postgres' }}
          POSTGRES_DB: ${{ secrets.PR_PREVIEW_POSTGRES_DB || 'refactor_platform' }}
          POSTGRES_SCHEMA: ${{ secrets.PR_PREVIEW_POSTGRES_SCHEMA || 'public' }}

          # Backend runtime configuration from variables
          RUST_ENV: ${{ vars.RUST_ENV || 'development' }}
          BACKEND_INTERFACE: ${{ vars.BACKEND_INTERFACE || '0.0.0.0' }}
          BACKEND_ALLOWED_ORIGINS: ${{ vars.BACKEND_ALLOWED_ORIGINS || '*' }}
          BACKEND_LOG_FILTER_LEVEL: ${{ vars.BACKEND_LOG_FILTER_LEVEL || 'info' }}
          BACKEND_SESSION_EXPIRY_SECONDS: ${{ vars.BACKEND_SESSION_EXPIRY_SECONDS || '86400' }}
          SERVICE_STARTUP_WAIT: ${{ vars.SERVICE_STARTUP_WAIT_SECONDS || '30' }}

          # Optional third-party service integrations (with fallbacks)
          TIPTAP_APP_ID: ${{ secrets.PR_PREVIEW_TIPTAP_APP_ID || '' }}
          TIPTAP_URL: ${{ secrets.PR_PREVIEW_TIPTAP_URL || '' }}
          TIPTAP_AUTH_KEY: ${{ secrets.PR_PREVIEW_TIPTAP_AUTH_KEY || '' }}
          TIPTAP_JWT_SIGNING_KEY: ${{ secrets.PR_PREVIEW_TIPTAP_JWT_SIGNING_KEY || '' }}
          MAILERSEND_API_KEY: ${{ secrets.PR_PREVIEW_MAILERSEND_API_KEY || '' }}
          WELCOME_EMAIL_TEMPLATE_ID: ${{ secrets.PR_PREVIEW_WELCOME_EMAIL_TEMPLATE_ID || '' }}
        run: |
          # Use consistent secret names from cleanup workflow
          # Transfer Docker Compose configuration to RPi5 via secure Tailscale tunnel
          echo "📦 Transferring compose file to neo..."
          scp -o StrictHostKeyChecking=accept-new docker-compose.pr-preview.yaml \
            ${{ secrets.NEO_SSH_USER }}@${{ secrets.NEO_SSH_HOST }}:/home/${{ secrets.NEO_SSH_USER }}/pr-${PR_NUMBER}-compose.yaml

          # Execute deployment script on RPi5 with comprehensive error handling
          echo "🚀 Deploying PR preview environment..."
          ssh -o StrictHostKeyChecking=accept-new ${{ secrets.NEO_SSH_USER }}@${{ secrets.NEO_SSH_HOST }} << 'ENDSSH'
            set -e  # Exit on any error
            
            # Export all environment variables for docker-compose substitution
            export PR_NUMBER="${PR_NUMBER}"
            export BACKEND_IMAGE="${BACKEND_IMAGE}"
            export PR_POSTGRES_PORT="${PR_POSTGRES_PORT}"
            export PR_BACKEND_PORT="${PR_BACKEND_PORT}"
            export PR_BACKEND_CONTAINER_PORT="${PR_BACKEND_CONTAINER_PORT}"
            export PR_FRONTEND_PORT="${PR_FRONTEND_PORT}"
            export POSTGRES_USER="${POSTGRES_USER}"
            export POSTGRES_PASSWORD="${POSTGRES_PASSWORD}"
            export POSTGRES_DB="${POSTGRES_DB}"
            export POSTGRES_SCHEMA="${POSTGRES_SCHEMA}"
            export RUST_ENV="${RUST_ENV}"
            export BACKEND_INTERFACE="${BACKEND_INTERFACE}"
            export BACKEND_ALLOWED_ORIGINS="${BACKEND_ALLOWED_ORIGINS}"
            export BACKEND_LOG_FILTER_LEVEL="${BACKEND_LOG_FILTER_LEVEL}"
            export BACKEND_SESSION_EXPIRY_SECONDS="${BACKEND_SESSION_EXPIRY_SECONDS}"
            export TIPTAP_APP_ID="${TIPTAP_APP_ID}"
            export TIPTAP_URL="${TIPTAP_URL}"
            export TIPTAP_AUTH_KEY="${TIPTAP_AUTH_KEY}"
            export TIPTAP_JWT_SIGNING_KEY="${TIPTAP_JWT_SIGNING_KEY}"
            export MAILERSEND_API_KEY="${MAILERSEND_API_KEY}"
            export WELCOME_EMAIL_TEMPLATE_ID="${WELCOME_EMAIL_TEMPLATE_ID}"
            
            cd /home/${{ secrets.NEO_SSH_USER }}
            
            # Authenticate with GitHub Container Registry to pull ARM64 images
            echo "📦 Logging into GHCR..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull the ARM64 image built specifically for this PR
            echo "📥 Pulling image: ${BACKEND_IMAGE}..."
            docker pull ${BACKEND_IMAGE}
            
            # Stop any existing environment to prevent conflicts
            echo "🛑 Stopping existing PR-${PR_NUMBER} environment..."
            docker compose -p ${PROJECT_NAME} -f pr-${PR_NUMBER}-compose.yaml down 2>/dev/null || true
            
            # Start the new preview environment with latest image
            echo "🚀 Starting PR preview environment..."
            docker compose -p ${PROJECT_NAME} -f pr-${PR_NUMBER}-compose.yaml up -d
            
            # Wait for services to initialize and become healthy
            echo "⏳ Waiting ${SERVICE_STARTUP_WAIT} seconds for services..."
            sleep ${SERVICE_STARTUP_WAIT}
            
            # Display deployment status for monitoring and debugging
            echo "🩺 Deployment status:"
            docker compose -p ${PROJECT_NAME} ps
            
            # Show recent migration logs for database setup verification
            echo "📜 Migration logs:"
            docker logs ${PROJECT_NAME}-migrator-1 2>&1 | tail -20 || echo "⚠️ Migrator exited"
            
            # Show recent backend logs for application startup verification
            echo "📜 Backend logs:"
            docker logs ${PROJECT_NAME}-backend-1 2>&1 | tail -20 || echo "⚠️ Backend starting"
            
            echo "✅ Deployment complete!"
            ENDSSH

      # Post deployment information to PR for developer access and testing
      # Creates or updates existing comment with current deployment details
      - name: Comment on PR with Preview URLs
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            // Extract deployment context from previous jobs
            const prNumber = ${{ needs.build-arm64-image.outputs.pr_number }};
            const backendPort = ${{ steps.ports.outputs.backend_port }};
            const postgresPort = ${{ steps.ports.outputs.postgres_port }};
            const frontendPort = ${{ steps.ports.outputs.frontend_port }};
            const backendBranch = '${{ needs.build-arm64-image.outputs.backend_branch }}';
            const imageTag = '${{ needs.build-arm64-image.outputs.image_tag_pr }}';
            const isNativeArm64 = '${{ needs.build-arm64-image.outputs.is_native_arm64 }}' === 'true';
            const backendUrl = `http://${{ secrets.NEO_SSH_HOST }}:${backendPort}`;
            const frontendUrl = `http://${{ secrets.NEO_SSH_HOST }}:${frontendPort}`;

            // Generate comprehensive deployment status comment
            const comment = `## 🚀 PR Preview Environment Deployed!

            ### 🔗 Access URLs
            | Service | URL |
            |---------|-----|
            | **Frontend** | [${frontendUrl}](${frontendUrl}) |
            | **Backend API** | [${backendUrl}](${backendUrl}) |
            | **Health Check** | [${backendUrl}/health](${backendUrl}/health) |

            ### 📊 Environment Details
            - **PR Number:** #${prNumber}
            - **Backend Branch:** \`${backendBranch}\`
            - **Commit:** \`${{ github.sha }}\`
            - **Image:** \`${imageTag}\`
            - **Ports:** Frontend: ${frontendPort} | Backend: ${backendPort} | Postgres: ${postgresPort}
            - **Build Type:** ${isNativeArm64 ? '🚀 Native ARM64' : '⚠️ ARM64 Emulation'}

            ### 🔐 Access Requirements
            1. **Connect to Tailscale** (required)
            2. Access frontend: ${frontendUrl}
            3. Access backend: ${backendUrl}

            ### 🧪 Testing
            \`\`\`bash
            # Health check
            curl ${backendUrl}/health

            # API test
            curl ${backendUrl}/api/v1/...
            \`\`\`

            ### 🧹 Cleanup
            _Environment auto-cleaned when PR closes/merges_

            ---
            *Deployed: ${new Date().toISOString()}*
            *Optimizations: ${isNativeArm64 ? 'ARM64 native' : 'ARM64 emulation'} + sccache + Rust cache + Docker BuildKit + parallel builds*`;

            // Find existing bot comment and update it, or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(c => 
              c.user.type === 'Bot' && c.body.includes('PR Preview Environment')
            );

            if (botComment) {
              // Update existing comment with latest deployment info
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment,
              });
            } else {
              // Create new comment for first deployment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment,
              });
            }

      # Display deployment summary for manual workflow runs (no PR to comment on)
      # Provides access information in workflow logs for debugging
      - name: Display Deployment Summary
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "::notice::✅ Deployment complete!"
          echo "::notice::🌐 Frontend: http://${{ secrets.NEO_SSH_HOST }}:${{ steps.ports.outputs.frontend_port }}"
          echo "::notice::🌐 Backend: http://${{ secrets.NEO_SSH_HOST }}:${{ steps.ports.outputs.backend_port }}"
          echo "::notice::🗄️  Postgres: ${{ secrets.NEO_SSH_HOST }}:${{ steps.ports.outputs.postgres_port }}"
          echo "::notice::📦 Image: ${{ needs.build-arm64-image.outputs.image_tag_pr }}"
          echo "::notice::🏗️  Build: ${{ needs.build-arm64-image.outputs.is_native_arm64 == 'true' && 'Native ARM64' || 'ARM64 Emulation' }}"
          echo "::notice::⚡ Built in parallel with main workflow's x86_64 docker build"
